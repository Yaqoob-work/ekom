// // import 'dart:convert';
// // import 'dart:ui';
// // import 'package:flutter/foundation.dart';
// // import 'package:flutter/material.dart';
// // import 'package:flutter/services.dart';
// // import 'package:flutter_svg/svg.dart';
// // import 'package:http/http.dart' as http;
// // import 'package:mobi_tv_entertainment/home_screen_pages/sub_vod_screen/horzontal_vod.dart';
// // import 'package:mobi_tv_entertainment/main.dart';
// // import 'package:mobi_tv_entertainment/home_screen_pages/webseries_screen/webseries_details_page.dart';
// // import 'package:mobi_tv_entertainment/provider/device_info_provider.dart';
// // import 'package:mobi_tv_entertainment/services/history_service.dart';
// // // import 'package:mobi_tv_entertainment/utils/session_manager.dart'; // Assuming SessionManager exists
// // import 'package:mobi_tv_entertainment/video_widget/custom_youtube_player.dart';
// // import 'package:mobi_tv_entertainment/video_widget/video_screen.dart';
// // import 'package:mobi_tv_entertainment/video_widget/youtube_webview_player.dart';
// // import 'package:provider/provider.dart';
// // import 'package:shared_preferences/shared_preferences.dart';

// // // Professional Color Palette
// // class ProfessionalColors {
// //   static const primaryDark = Color(0xFF0A0E1A);
// //   static const surfaceDark = Color(0xFF1A1D29);
// //   static const cardDark = Color(0xFF2A2D3A);
// //   static const accentBlue = Color(0xFF3B82F6);
// //   static const accentPurple = Color(0xFF8B5CF6);
// //   static const accentGreen = Color(0xFF10B981);
// //   static const accentRed = Color(0xFFEF4444);
// //   static const accentOrange = Color(0xFFF59E0B);
// //   static const accentPink = Color(0xFFEC4899);
// //   static const textPrimary = Color(0xFFFFFFFF);
// //   static const textSecondary = Color(0xFFB3B3B3);
// //   static const focusGlow = Color(0xFF60A5FA);
// // }

// // // Data Models
// // class GenreResponse {
// //   final bool status;
// //   final List<String> genres;
// //   GenreResponse({required this.status, required this.genres});
// //   factory GenreResponse.fromJson(Map<String, dynamic> json) {
// //     return GenreResponse(
// //       status: json['status'],
// //       genres: List<String>.from(json['genres']),
// //     );
// //   }
// // }

// // class MovieResponse {
// //   final bool status;
// //   final int total;
// //   final List<Movie> data;
// //   MovieResponse({required this.status, required this.total, required this.data});
// //   factory MovieResponse.fromJson(Map<String, dynamic> json) {
// //     return MovieResponse(
// //       status: json['status'],
// //       total: json['total'],
// //       data: (json['data'] as List).map((i) => Movie.fromJson(i)).toList(),
// //     );
// //   }
// // }
// // class Movie {
// //   final int id;
// //   final String name;
// //   final String? banner;
// //   final String? poster;
// //   final String? description;
// //   final int? contentType;
// //   final String? sourceType;
// //   final String? youtubeTrailer;
// //   final String? updatedAt;
// //   final String? movieUrl;
// //   final int? status;

// //   Movie({
// //     required this.id,
// //     required this.name,
// //     this.banner,
// //     this.poster,
// //     this.description,
// //     this.contentType,
// //     this.sourceType,
// //     this.youtubeTrailer,
// //     this.updatedAt,
// //     this.movieUrl,
// //     this.status,
// //   });

// //   factory Movie.fromJson(Map<String, dynamic> json) {
// //     return Movie(
// //       id: json['id'],
// //       name: json['name'],
// //       banner: json['banner'],
// //       poster: json['poster'],
// //       description: json['description'],
// //       contentType: json['content_type'],
// //       sourceType: json['source_type'],
// //       youtubeTrailer: json['youtube_trailer'],
// //       updatedAt: json['updated_at'],
// //       movieUrl: json['movie_url'],
// //       status: json['status'],
// //     );
// //   }

// //   Map<String, dynamic> toMap() {
// //     return {
// //       'id': id, 'name': name, 'banner': banner, 'poster': poster,
// //       'description': description, 'content_type': contentType, 'source_type': sourceType,
// //       'youtube_trailer': youtubeTrailer, 'updated_at': updatedAt, 'movie_url': movieUrl,
// //       'status': status,
// //     };
// //   }

// //   factory Movie.fromMap(Map<String, dynamic> map) {
// //     return Movie.fromJson(map);
// //   }

// //   String getPlayableUrl() {
// //     if (sourceType == 'YoutubeLive') {
// //       return movieUrl ?? '';
// //     }
// //     if (youtubeTrailer != null && youtubeTrailer!.isNotEmpty) {
// //       return youtubeTrailer!;
// //     }
// //     return movieUrl ?? '';
// //   }
// // }

// // Future<String> _fetchAndCacheDataIsolate(Map<String, String> params) async {
// //   final String tvChannelId = params['tvChannelId']!;
// //   final String authKey = params['authKey']!;

// //   try {
// //     final genresResponse = await http.get(
// //       Uri.parse('https://dashboard.cpplayers.com/api/v2/getGenreByContentNetwork/$tvChannelId'),
// //       headers: {'auth-key': authKey, 'Accept': 'application/json', 'domain': 'coretechinfo.com'},
// //     );

// //     if (genresResponse.statusCode != 200) {
// //       throw Exception('Failed to load genres in isolate');
// //     }
// //     final genreData = GenreResponse.fromJson(json.decode(genresResponse.body));
// //     if (!genreData.status) {
// //       return '';
// //     }

// //     final genres = genreData.genres;
// //     final Map<String, List<Movie>> moviesByGenre = {};

// //     for (final genre in genres) {
// //       final moviesResponse = await http.post(
// //         Uri.parse('https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew?page=1&records=10'),
// //         headers: {'auth-key': authKey, 'domain': 'coretechinfo.com', 'Accept': 'application/json', 'Content-Type': 'application/json'},
// //         body: json.encode({"genre": genre, "network_id": tvChannelId}),
// //       );

// //       if (moviesResponse.statusCode == 200) {
// //         final movieData = MovieResponse.fromJson(json.decode(moviesResponse.body));
// //         if (movieData.status && movieData.data.isNotEmpty) {
// //           final activeMovies = movieData.data.where((movie) => movie.status == 1).toList();
// //           if (activeMovies.isNotEmpty) {
// //             moviesByGenre[genre] = activeMovies;
// //           }
// //         }
// //       }
// //     }
    
// //     final Map<String, dynamic> serializableData = {
// //       'genres': genres,
// //       'moviesByGenre': moviesByGenre.map((key, value) => MapEntry(key, value.map((m) => m.toMap()).toList())),
// //     };

// //     return json.encode(serializableData);
// //   } catch (e) {
// //     print("Isolate Error: $e");
// //     return '';
// //   }
// // }


// // class GenreMoviesScreen extends StatefulWidget {
// //   final String tvChannelId;
// //   final String logoUrl;
// //   final String title;

// //   const GenreMoviesScreen({
// //     super.key,
// //     required this.tvChannelId,
// //     required this.logoUrl,
// //     required this.title,
// //   });

// //   @override
// //   State<GenreMoviesScreen> createState() => _GenreMoviesScreenState();
// // }

// // class _GenreMoviesScreenState extends State<GenreMoviesScreen> {
// //   bool _isLoading = true;
// //   String? _error;
// //   List<String> _genres = [];
// //   final Map<String, List<Movie>> _moviesByGenre = {};
  
// //   final List<List<FocusNode>> _focusNodes = [];
// //   final ScrollController _verticalScrollController = ScrollController();
// //   final Map<int, ScrollController> _horizontalScrollControllers = {};
// //   final List<GlobalKey> _rowKeys = [];
// //   final List<List<GlobalKey>> _cardKeys = [];

// //   final List<Color> _focusColors = [
// //     ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen,
// //     ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed,
// //   ];
// //   final List<Gradient> _genreBackgrounds = const [
// //     LinearGradient(colors: [Color(0xFF1A1D29), Color(0xFF0F121E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
// //     LinearGradient(colors: [Color(0xFF1C1A29), Color(0xFF110F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
// //     LinearGradient(colors: [Color(0xFF1A2129), Color(0xFF0F161E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
// //     LinearGradient(colors: [Color(0xFF211A29), Color(0xFF160F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
// //   ];
// //   bool _isVideoLoading = false;
  
// //   String _focusedItemName = '';

// //   String get _cacheKey => 'genre_movies_cache_${widget.tvChannelId}';

// //   @override
// //   void initState() {
// //     super.initState();
// //     _focusedItemName = ''; // Initialize with the screen's static title.
// //     _loadInitialData();
// //   }
  
// //   @override
// //   void dispose() {
// //     for (var row in _focusNodes) {
// //       for (var node in row) {
// //         node.dispose();
// //       }
// //     }
// //     _verticalScrollController.dispose();
// //     _horizontalScrollControllers.values.forEach((controller) => controller.dispose());
// //     super.dispose();
// //   }
  
// //   Future<void> _loadInitialData() async {
// //     final prefs = await SharedPreferences.getInstance();
// //     final cachedData = prefs.getString(_cacheKey);

// //     if (cachedData != null && cachedData.isNotEmpty) {
// //       _parseAndSetState(cachedData);
// //       setState(() { _isLoading = false; });
// //       _refreshDataInBackground();
// //     } else {
// //       await _fetchDataWithLoading();
// //     }
// //   }
  
// //   Future<void> _refreshDataInBackground() async {
// //     try {
// //       final prefs = await SharedPreferences.getInstance();
// //       final authKey = prefs.getString('result_auth_key') ?? '';

// //       final String freshDataJson = await compute(_fetchAndCacheDataIsolate, {
// //         'tvChannelId': widget.tvChannelId,
// //         'authKey': authKey,
// //       });

// //       if (freshDataJson.isNotEmpty) {
// //         await prefs.setString(_cacheKey, freshDataJson);
// //         print("Cache successfully updated in the background.");
// //       }
// //     } catch (e) {
// //       print("Background refresh failed: $e");
// //     }
// //   }
  
// //   Future<void> _fetchDataWithLoading() async {
// //     setState(() { _isLoading = true; });
// //     try {
// //       final prefs = await SharedPreferences.getInstance();
// //       final authKey = prefs.getString('result_auth_key') ?? '';

// //       final String freshDataJson = await _fetchAndCacheDataIsolate({
// //         'tvChannelId': widget.tvChannelId,
// //         'authKey': authKey,
// //       });

// //       if (freshDataJson.isNotEmpty) {
// //         await prefs.setString(_cacheKey, freshDataJson);
// //         _parseAndSetState(freshDataJson);
// //       } else {
// //         throw Exception('Failed to load data');
// //       }
// //     } catch (e) {
// //       if (mounted) setState(() => _error = e.toString());
// //     } finally {
// //       if (mounted) setState(() => _isLoading = false);
// //     }
// //   }



// // //   // 1. _parseAndSetState method में changes
// // // void _parseAndSetState(String jsonData) {
// // //   final data = json.decode(jsonData) as Map<String, dynamic>;
  
// // //   _focusNodes.clear();
// // //   _cardKeys.clear();
// // //   _rowKeys.clear();
// // //   _horizontalScrollControllers.values.forEach((c) => c.dispose());
// // //   _horizontalScrollControllers.clear();

// // //   _genres = List<String>.from(data['genres']);
// // //   _moviesByGenre.clear();
// // //   _moviesByGenre.addAll((data['moviesByGenre'] as Map<String, dynamic>).map(
// // //     (key, value) => MapEntry(
// // //       key,
// // //       (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList(),
// // //     ),
// // //   ));

// // //   _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));

// // //   for (int i = 0; i < _genres.length; i++) {
// // //     final genre = _genres[i];
// // //     final movies = _moviesByGenre[genre] ?? [];
// // //     if (movies.isEmpty) continue;

// // //     // MODIFIED: हमेशा View All card add करने के लिए +1 करें
// // //     // लेकिन maximum 10 movies + 1 View All = 11 items तक ही
// // //     int moviesToShow = movies.length > 10 ? 10 : movies.length;
// // //     int nodeCount = moviesToShow + 1; // हमेशा View All के लिए +1
    
// // //     var rowNodes = List.generate(nodeCount, (_) => FocusNode());
// // //     var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
// // //     _cardKeys.add(rowCardKeys);
    
// // //     _horizontalScrollControllers[i] = ScrollController();

// // //     for (int j = 0; j < nodeCount; j++) {
// // //       rowNodes[j].addListener(() {
// // //         if (rowNodes[j].hasFocus) {
// // //           _onItemFocusChange(i, j);
// // //         }
// // //       });
// // //     }
// // //     _focusNodes.add(rowNodes);
// // //   }

// // //   if(mounted) {
// // //     setState(() {});
// // //     Future.delayed(const Duration(milliseconds: 200), () {
// // //       if (_focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
// // //         _focusNodes.first.first.requestFocus();
// // //       }
// // //     });
// // //   }
// // // }




// // void _parseAndSetState(String jsonData) {
// //   final data = json.decode(jsonData) as Map<String, dynamic>;

// //   // Clear all previous state
// //   _focusNodes.clear();
// //   _cardKeys.clear();
// //   _rowKeys.clear();
// //   _horizontalScrollControllers.values.forEach((c) => c.dispose());
// //   _horizontalScrollControllers.clear();

// //   final allGenres = List<String>.from(data['genres']);
// //   final allMoviesByGenre = (data['moviesByGenre'] as Map<String, dynamic>).map(
// //     (key, value) => MapEntry(
// //       key,
// //       (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList(),
// //     ),
// //   );

// //   // *** FIX: Filter genres first, exactly like in the build method ***
// //   final activeGenres = allGenres.where((g) => allMoviesByGenre[g]?.isNotEmpty ?? false).toList();

// //   // Now, update the state variables with the filtered/active data
// //   _genres = activeGenres;
// //   _moviesByGenre.clear();
// //   _moviesByGenre.addAll(allMoviesByGenre);
  
// //   _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));

// //   // *** FIX: Loop over the active genres list ***
// //   for (int i = 0; i < _genres.length; i++) {
// //     final genre = _genres[i];
// //     final movies = _moviesByGenre[genre] ?? [];
// //     // The check `if (movies.isEmpty)` is no longer needed because we already filtered

// //     int moviesToShow = movies.length > 10 ? 10 : movies.length;
// //     int nodeCount = moviesToShow + 1; // +1 for "View All"

// //     var rowNodes = List.generate(nodeCount, (_) => FocusNode());
// //     var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
// //     _cardKeys.add(rowCardKeys);
    
// //     _horizontalScrollControllers[i] = ScrollController();

// //     for (int j = 0; j < nodeCount; j++) {
// //       rowNodes[j].addListener(() {
// //         if (rowNodes[j].hasFocus) {
// //           // The index 'i' is now always correct because we are iterating over the active list
// //           _onItemFocusChange(i, j);
// //         }
// //       });
// //     }
// //     _focusNodes.add(rowNodes);
// //   }

// //   if (mounted) {
// //     setState(() {});
// //     Future.delayed(const Duration(milliseconds: 200), () {
// //       if (_focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
// //         _focusNodes.first.first.requestFocus();
// //       }
// //     });
// //   }
// // }

// // // 2. _onItemFocusChange method में changes
// // void _onItemFocusChange(int genreIndex, int movieIndex) {
// //   final genre = _genres[genreIndex];
// //   final movies = _moviesByGenre[genre] ?? [];
  
// //   // MODIFIED: View All की position check करें
// //   int moviesToShow = movies.length > 10 ? 10 : movies.length;
  
// //   if (movieIndex < moviesToShow) {
// //     final Movie focusedMovie = movies[movieIndex];
// //     if (mounted) setState(() => _focusedItemName = focusedMovie.name);
// //   } else {
// //     // यह View All card है
// //     if (mounted) setState(() => _focusedItemName = "View All");
// //   }

// //   _scrollToFocusedVertical(genreIndex);
// //   _scrollToFocusedHorizontal(genreIndex, movieIndex);
// // }




// // // // 3. _buildGenresList method में ListView.builder का itemBuilder modify करें
// // // Widget _buildGenresList() {
// // //   final activeGenres = _genres.where((genre) => _moviesByGenre[genre]?.isNotEmpty ?? false).toList();
  
// // //   return SliverList(
// // //     delegate: SliverChildBuilderDelegate(
// // //       (context, index) {
// // //         final genre = activeGenres[index];
// // //         final genreIndexInOriginal = _genres.indexOf(genre);
// // //         final movies = _moviesByGenre[genre] ?? [];

// // //         // MODIFIED: Maximum 10 movies show करें, फिर View All
// // //         final int moviesToShow = movies.length > 10 ? 10 : movies.length;
// // //         final int itemCount = moviesToShow + 1; // हमेशा View All के लिए +1

// // //         return Container(
// // //           key: _rowKeys[genreIndexInOriginal],
// // //           decoration: BoxDecoration(gradient: _genreBackgrounds[genreIndexInOriginal % _genreBackgrounds.length]),
// // //           padding: const EdgeInsets.symmetric(vertical: 5.0),
// // //           child: Column(
// // //             crossAxisAlignment: CrossAxisAlignment.start,
// // //             children: [
// // //               Padding(
// // //                 padding: const EdgeInsets.only(left: 30.0, bottom: 5.0),
// // //                 child: GradientText(
// // //                   genre,
// // //                   style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, letterSpacing: 1.2),
// // //                   gradient: const LinearGradient(
// // //                     colors: [
// // //                       ProfessionalColors.accentGreen,
// // //                       ProfessionalColors.accentOrange,
// // //                       ProfessionalColors.accentPink,
// // //                     ],
// // //                     begin: Alignment.topLeft,
// // //                     end: Alignment.bottomRight,
// // //                   ),
// // //                 ),
// // //               ),
// // //               SizedBox(
// // //                 height: bannerhgt + 25,
// // //                 child: ListView.builder(
// // //                   controller: _horizontalScrollControllers[genreIndexInOriginal],
// // //                   scrollDirection: Axis.horizontal,
// // //                   itemCount: itemCount,
// // //                   padding: const EdgeInsets.symmetric(horizontal: 30.0),
// // //                   itemBuilder: (context, movieIndex) {
// // //                     // MODIFIED: View All card की condition
// // //                     if (movieIndex == moviesToShow) {
// // //                       // यह View All card है (हमेशा last position पर)
// // //                       return ViewAllCard(
// // //                         key: _cardKeys[genreIndexInOriginal][movieIndex],
// // //                         focusNode: _focusNodes[genreIndexInOriginal][movieIndex],
// // //                         focusColors: _focusColors,
// // //                         uniqueIndex: genreIndexInOriginal * 10 + movieIndex,
// // //                         onTap: () => _navigateToGridPage(genre),
// // //                       );
// // //                     }
                    
// // //                     final movie = movies[movieIndex];
// // //                     return MovieCard(
// // //                       key: _cardKeys[genreIndexInOriginal][movieIndex],
// // //                       movie: movie,
// // //                       logoUrl: widget.logoUrl,
// // //                       focusNode: _focusNodes[genreIndexInOriginal][movieIndex],
// // //                       focusColors: _focusColors,
// // //                       uniqueIndex: genreIndexInOriginal * 10 + movieIndex,
// // //                       onTap: () => _playContent(movie),
// // //                       isFirst: movieIndex == 0,
// // //                       // isLast: movieIndex == moviesToShow - 1, // Last movie card
// // //                       isLast: false,
// // //                     );
// // //                   },
// // //                 ),
// // //               ),
// // //             ],
// // //           ),
// // //         );
// // //       },
// // //       childCount: activeGenres.length,
// // //     ),
// // //   );
// // // }



// // Widget _buildGenresList() {
// //   // *** NOTE: The 'activeGenres' logic is now handled in _parseAndSetState ***
// //   // We can directly use the state's `_genres` list which is already filtered.
  
// //   return SliverList(
// //     delegate: SliverChildBuilderDelegate(
// //       (context, index) {
// //         // *** FIX: The 'index' from the builder is now the correct index ***
// //         final genre = _genres[index];
// //         // final genreIndexInOriginal = _genres.indexOf(genre); // This line is NO LONGER NEEDED
// //         final movies = _moviesByGenre[genre] ?? [];

// //         final int moviesToShow = movies.length > 10 ? 10 : movies.length;
// //         final int itemCount = moviesToShow + 1;

// //         return Container(
// //           // Use the direct 'index'
// //           key: _rowKeys[index],
// //           decoration: BoxDecoration(gradient: _genreBackgrounds[index % _genreBackgrounds.length]),
// //           padding: const EdgeInsets.symmetric(vertical: 5.0),
// //           child: Column(
// //             crossAxisAlignment: CrossAxisAlignment.start,
// //             children: [

// //                                             Padding(
// //                 padding: const EdgeInsets.only(left: 30.0, bottom: 5.0),
// //                 child: GradientText(
// //                   genre,
// //                   style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, letterSpacing: 1.2),
// //                   gradient: const LinearGradient(
// //                     colors: [
// //                       ProfessionalColors.accentGreen,
// //                       ProfessionalColors.accentOrange,
// //                       ProfessionalColors.accentPink,
// //                     ],
// //                     begin: Alignment.topLeft,
// //                     end: Alignment.bottomRight,
// //                   ),
// //                 ),
// //               ),
              
// //               SizedBox(
// //                 height: bannerhgt + 25,
// //                 child: ListView.builder(
// //                   // Use the direct 'index'
// //                   controller: _horizontalScrollControllers[index],
// //                   scrollDirection: Axis.horizontal,
// //                   itemCount: itemCount,
// //                   padding: const EdgeInsets.symmetric(horizontal: 30.0),
// //                   itemBuilder: (context, movieIndex) {
// //                     if (movieIndex == moviesToShow) {
// //                       return ViewAllCard(
// //                         // Use the direct 'index'
// //                         key: _cardKeys[index][movieIndex],
// //                         focusNode: _focusNodes[index][movieIndex],
// //                         focusColors: _focusColors,
// //                         uniqueIndex: index * 10 + movieIndex,
// //                         onTap: () => _navigateToGridPage(genre),
// //                       );
// //                     }
                    
// //                     final movie = movies[movieIndex];
// //                     return MovieCard(
// //                       // Use the direct 'index'
// //                       key: _cardKeys[index][movieIndex],
// //                       movie: movie,
// //                       logoUrl: widget.logoUrl,
// //                       focusNode: _focusNodes[index][movieIndex],
// //                       focusColors: _focusColors,
// //                       uniqueIndex: index * 10 + movieIndex,
// //                       onTap: () => _playContent(movie),
// //                       isFirst: movieIndex == 0,
// //                       isLast: false,
// //                     );
// //                   },
// //                 ),
// //               ),
// //             ],
// //           ),
// //         );
// //       },
// //       // Use the length of the already-filtered _genres list
// //       childCount: _genres.length,
// //     ),
// //   );
// // }

// // //   void _parseAndSetState(String jsonData) {
// // //     final data = json.decode(jsonData) as Map<String, dynamic>;
    
// // //     _focusNodes.clear();
// // //     _cardKeys.clear();
// // //     _rowKeys.clear();
// // //     _horizontalScrollControllers.values.forEach((c) => c.dispose());
// // //     _horizontalScrollControllers.clear();

// // //     _genres = List<String>.from(data['genres']);
// // //     _moviesByGenre.clear();
// // //     _moviesByGenre.addAll((data['moviesByGenre'] as Map<String, dynamic>).map(
// // //       (key, value) => MapEntry(
// // //         key,
// // //         (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList(),
// // //       ),
// // //     ));

// // //     _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));

// // //     for (int i = 0; i < _genres.length; i++) {
// // //       final genre = _genres[i];
// // //       final movies = _moviesByGenre[genre] ?? [];
// // //       if (movies.isEmpty) continue;

// // //       int nodeCount = movies.length + (movies.length == 7 ? 1 : 0);
      
// // //       var rowNodes = List.generate(nodeCount, (_) => FocusNode());
// // //       var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
// // //       _cardKeys.add(rowCardKeys);
      
// // //       _horizontalScrollControllers[i] = ScrollController();

// // //       for (int j = 0; j < nodeCount; j++) {
// // //         rowNodes[j].addListener(() {
// // //           if (rowNodes[j].hasFocus) {
// // //             _onItemFocusChange(i, j);
// // //           }
// // //         });
// // //       }
// // //       _focusNodes.add(rowNodes);
// // //     }

// // //     if(mounted) {
// // //       setState(() {});
// // //       Future.delayed(const Duration(milliseconds: 200), () {
// // //         if (_focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
// // //           _focusNodes.first.first.requestFocus();
// // //         }
// // //       });
// // //     }
// // //   }
  
// // // void _onItemFocusChange(int genreIndex, int movieIndex) {
// // //   final genre = _genres[genreIndex];
// // //   final movies = _moviesByGenre[genre] ?? [];
// // //   if (movieIndex < movies.length) {
// // //     final Movie focusedMovie = movies[movieIndex];
// // //     if (mounted) setState(() => _focusedItemName = focusedMovie.name);
// // //   } else {
// // //     if (mounted) setState(() => _focusedItemName = "View All");
// // //   }

// // //   _scrollToFocusedVertical(genreIndex);
// // //   _scrollToFocusedHorizontal(genreIndex, movieIndex);
// // // }

// // void _scrollToFocusedVertical(int genreIndex) {
// //   final rowContext = _rowKeys[genreIndex].currentContext;
// //   if (rowContext == null) return;

// //   final renderBox = rowContext.findRenderObject() as RenderBox;
// //   final rowOffset = renderBox.localToGlobal(Offset.zero);
// //   final scrollOffset = _verticalScrollController.offset;

// //   const appBarHeight = 100.0; // Adjusted for new AppBar
// //   final rowTop = rowOffset.dy + scrollOffset - (screenhgt * 0.5 - appBarHeight * 0.5);

// //   _verticalScrollController.animateTo(
// //     rowTop.clamp(0.0, _verticalScrollController.position.maxScrollExtent),
// //     duration: const Duration(milliseconds: 350),
// //     curve: Curves.easeOut,
// //   );
// // }

// // void _scrollToFocusedHorizontal(int genreIndex, int movieIndex) {
// //   final scrollController = _horizontalScrollControllers[genreIndex];
// //   if (scrollController == null) return;
  
// //   final cardContext = _cardKeys[genreIndex][movieIndex].currentContext;
// //   if (cardContext == null) return;
  
// //   final renderBox = cardContext.findRenderObject() as RenderBox;
// //   final cardOffset = renderBox.localToGlobal(Offset.zero, ancestor: scrollController.position.context.storageContext.findRenderObject());
  
// //   double targetOffset = scrollController.offset + cardOffset.dx - 40;
  
// //   targetOffset = targetOffset.clamp(0.0, scrollController.position.maxScrollExtent);
  
// //   scrollController.animateTo(
// //     targetOffset,
// //     duration: const Duration(milliseconds: 300),
// //     curve: Curves.easeOut,
// //   );
// // }
  
// //   Future<void> _playContent(Movie content) async {
// //     if (_isVideoLoading || !mounted) return;
// //     setState(() { _isVideoLoading = true; });
// //     try {
// //       String playableUrl = content.getPlayableUrl();
// //       try {
// //         // await HistoryService.updateUserHistory(...);
// //       } catch (e) { print("History update failed, but proceeding to play. Error: $e"); }
// //       if (content.contentType == 2) {
// //         await Navigator.push(context, MaterialPageRoute(builder: (context) => WebSeriesDetailsPage(
// //             id: content.id, banner: content.banner ?? '', poster: content.poster ?? '',
// //             logo: widget.logoUrl, name: content.name, updatedAt: content.updatedAt ?? '',
// //           ),),);
// //         return;
// //       }
// //       if (playableUrl.isEmpty) { throw Exception('No video URL found'); }
// //       if (!mounted) return;
// //       if (content.sourceType == 'YoutubeLive' || (content.youtubeTrailer != null && content.youtubeTrailer!.isNotEmpty)) {
// //         final deviceInfo = context.read<DeviceInfoProvider>();
// //         if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
// //           await Navigator.push(context, MaterialPageRoute(builder: (context) => YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
// //         } else {
// //           await Navigator.push(context, MaterialPageRoute(builder: (context) => CustomYoutubePlayer(
// //               videoData: VideoData(
// //                 id: content.id.toString(), title: content.name, youtubeUrl: playableUrl,
// //                 thumbnail: content.poster ?? content.banner ?? '', description: content.description ?? '',
// //               ), playlist: [],
// //             )));
// //         }
// //       } else {
// //         await Navigator.push(context, MaterialPageRoute( builder: (context) => VideoScreen(
// //             videoUrl: playableUrl, bannerImageUrl: content.poster ?? content.banner ?? '',
// //             videoId: content.id, name: content.name, updatedAt: content.updatedAt ?? '',
// //             source: 'isVod', channelList: [], liveStatus: false,
// //           ),),);
// //       }
// //     } catch (e) {
// //       if (mounted) { ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}'))); }
// //     } finally {
// //       if (mounted) { setState(() { _isVideoLoading = false; }); }
// //     }
// //   }

// //   void _navigateToGridPage(String genre) {
// //     Navigator.push(context, MaterialPageRoute(builder: (context) => GenreGridScreen(
// //       genre: genre, tvChannelId: widget.tvChannelId, logoUrl: widget.logoUrl,
// //     ),),);
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     return Scaffold(
// //       backgroundColor: ProfessionalColors.primaryDark,
// //       body: Stack(
// //         children: [
// //           // Background Gradient
// //           Container(
// //             decoration: const BoxDecoration(
// //               gradient: LinearGradient(
// //                 colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)],
// //                 begin: Alignment.topCenter,
// //                 end: Alignment.bottomCenter,
// //               ),
// //             ),
// //           ),
// //           // Main Scrollable Content
// //           CustomScrollView(
// //             controller: _verticalScrollController,
// //             slivers: [
// //               // Padding to prevent content from being hidden by the custom AppBar
// //               SliverPadding(padding: EdgeInsets.only(top: 100.0)),
// //               _isLoading
// //                   ? const SliverFillRemaining(
// //                       child: Center(child: CircularProgressIndicator()))
// //                   : _error != null
// //                       ? SliverFillRemaining(
// //                           child: Center(child: Text('Error: $_error')))
// //                       : _buildGenresList(),
// //             ],
// //           ),
// //           // The new fixed AppBar positioned on top
// //           Positioned(
// //             top: 0,
// //             left: 0,
// //             right: 0,
// //             child: _buildBeautifulAppBar(),
// //           ),
// //           // Loading indicator overlay
// //           if (_isVideoLoading)
// //             Container(
// //               color: Colors.black.withOpacity(0.7),
// //               child: const Center(
// //                   child: CircularProgressIndicator(
// //                       valueColor: AlwaysStoppedAnimation<Color>(Colors.white))),
// //             ),
// //         ],
// //       ),
// //     );
// //   }

// //   Widget _buildBeautifulAppBar() {
// //     return Container(
// //       decoration: BoxDecoration(
// //         gradient: LinearGradient(
// //           begin: Alignment.topCenter,
// //           end: Alignment.bottomCenter,
// //           colors: [
// //             ProfessionalColors.primaryDark.withOpacity(0.95),
// //             ProfessionalColors.surfaceDark.withOpacity(0.9),
// //             ProfessionalColors.surfaceDark.withOpacity(0.8),
// //             Colors.transparent,
// //           ],
// //         ),
// //         border: Border(
// //           bottom: BorderSide(
// //             color: ProfessionalColors.accentBlue.withOpacity(0.2),
// //             width: 1,
// //           ),
// //         ),
// //         boxShadow: [
// //           BoxShadow(
// //             color: Colors.black.withOpacity(0.3),
// //             blurRadius: 10,
// //             offset: const Offset(0, 2),
// //           ),
// //         ],
// //       ),
// //       child: ClipRRect(
// //         child: BackdropFilter(
// //           filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
// //           child: Container(
// //             padding: EdgeInsets.only(
// //               top: MediaQuery.of(context).padding.top + 10,
// //               left: 20,
// //               right: 30,
// //               bottom: 10,
// //             ),
// //             child: Row(
// //               children: [

// //                 // Back Button
// //                 Container(
// //                   decoration: BoxDecoration(
// //                     shape: BoxShape.circle,
// //                     gradient: LinearGradient(
// //                       colors: [
// //                         ProfessionalColors.accentBlue.withOpacity(0.3),
// //                         ProfessionalColors.accentPurple.withOpacity(0.3),
// //                       ],
// //                     ),
// //                   ),
// //                   child: IconButton(
// //                     icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24),
// //                     onPressed: () => Navigator.pop(context),
// //                   ),
// //                 ),
// //                 const SizedBox(width: 16),

// //                 // MODIFIED: Replaced Text with GradientText for the main title
// //                 GradientText(
// //                   widget.title,
// //                   style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22),
// //                   gradient: const LinearGradient(colors: [
// //                     ProfessionalColors.accentPink,
// //                     ProfessionalColors.accentPurple,
// //                     ProfessionalColors.accentBlue,
// //                   ]),
// //                 ),
// //                 const SizedBox(width: 40),
// //                 // Focused Banner Name (in remaining space)
// //                 Expanded(
// //                   child: Text(
// //                     _focusedItemName,
// //                     textAlign: TextAlign.left,
// //                     style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20),
// //                     overflow: TextOverflow.ellipsis,
// //                   ),
// //                 ),

// //                 // Logo
// //                 Padding(
// //                   padding: const EdgeInsets.only(right: 15.0),
// //                   child: CircleAvatar(
// //                     backgroundImage: NetworkImage(widget.logoUrl),
// //                     radius: 20,
// //                     backgroundColor: Colors.white24,
// //                   ),
// //                 ),
// //               ],
// //             ),
// //           ),
// //         ),
// //       ),
// //     );
// //   }

// // //   Widget _buildGenresList() {
// // //     final activeGenres = _genres.where((genre) => _moviesByGenre[genre]?.isNotEmpty ?? false).toList();
    
// // //     return SliverList(
// // //       delegate: SliverChildBuilderDelegate(
// // //         (context, index) {
// // //           final genre = activeGenres[index];
// // //           final genreIndexInOriginal = _genres.indexOf(genre);
// // //           final movies = _moviesByGenre[genre] ?? [];

// // //           final bool hasViewAll = movies.length == 7;
// // //           final int itemCount = movies.length + (hasViewAll ? 1 : 0);

// // //           return Container(
// // //             key: _rowKeys[genreIndexInOriginal],
// // //             decoration: BoxDecoration(gradient: _genreBackgrounds[genreIndexInOriginal % _genreBackgrounds.length]),
// // //             padding: const EdgeInsets.symmetric(vertical: 5.0),
// // //             child: Column(
// // //               crossAxisAlignment: CrossAxisAlignment.start,
// // //               children: [
// // //                 Padding(
// // //                   padding: const EdgeInsets.only(left: 30.0, bottom: 5.0),
// // //                   // MODIFIED: Replaced Text with GradientText for genre titles
// // //                   child: GradientText(
// // //                     genre,
// // //                     style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, letterSpacing: 1.2),
// // //                     gradient: const LinearGradient(
// // //                       colors: [
// // //                         ProfessionalColors.accentGreen,
// // //                         ProfessionalColors.accentOrange,
// // //                         ProfessionalColors.accentPink,
// // //                       ],
// // //                       begin: Alignment.topLeft,
// // //                       end: Alignment.bottomRight,
// // //                     ),
// // //                   ),
// // //                 ),
// // //                 SizedBox(
// // //                   height: bannerhgt + 25,
// // //                   child: ListView.builder(
// // //                     controller: _horizontalScrollControllers[genreIndexInOriginal],
// // //                     scrollDirection: Axis.horizontal,
// // //                     itemCount: itemCount,
// // //                     padding: const EdgeInsets.symmetric(horizontal: 30.0),
// // //                     itemBuilder: (context, movieIndex) {
// // //                       if (hasViewAll && movieIndex == movies.length) {
// // //                         return ViewAllCard(
// // //                           key: _cardKeys[genreIndexInOriginal][movieIndex],
// // //                           focusNode: _focusNodes[genreIndexInOriginal][movieIndex],
// // //                           focusColors: _focusColors,
// // //                           uniqueIndex: genreIndexInOriginal * 10 + movieIndex,
// // //                           onTap: () => _navigateToGridPage(genre),
// // //                         );
// // //                       }
                      
// // //                       final movie = movies[movieIndex];
// // //                       return MovieCard(
// // //                         key: _cardKeys[genreIndexInOriginal][movieIndex],
// // //                         movie: movie,
// // //                         logoUrl: widget.logoUrl,
// // //                         focusNode: _focusNodes[genreIndexInOriginal][movieIndex],
// // //                         focusColors: _focusColors,
// // //                         uniqueIndex: genreIndexInOriginal * 10 + movieIndex,
// // //                         onTap: () => _playContent(movie),
// // //                         isFirst: movieIndex == 0,
// // //                         isLast: !hasViewAll && movieIndex == movies.length - 1,
// // //                       );
// // //                     },
// // //                   ),
// // //                 ),
// // //               ],
// // //             ),
// // //           );
// // //         },
// // //         childCount: activeGenres.length,
// // //       ),
// // //     );
// // //   }
// // }

// // class MovieCard extends StatefulWidget {
// //   final Movie movie;
// //   final String logoUrl;
// //   final FocusNode focusNode;
// //   final List<Color> focusColors;
// //   final int uniqueIndex;
// //   final VoidCallback onTap;
// //   final bool isFirst;
// //   final bool isLast;

// //   const MovieCard({
// //     super.key,
// //     required this.movie,
// //     required this.logoUrl,
// //     required this.focusNode,
// //     required this.focusColors,
// //     required this.uniqueIndex,
// //     required this.onTap,
// //     this.isFirst = false,
// //     this.isLast = false,
// //   });

// //   @override
// //   State<MovieCard> createState() => _MovieCardState();
// // }

// // class _MovieCardState extends State<MovieCard> {
// //   bool _hasFocus = false;

// //   @override
// //   void initState() {
// //     super.initState();
// //     widget.focusNode.addListener(_onFocusChange);
// //   }

// //   @override
// //   void dispose() {
// //     widget.focusNode.removeListener(_onFocusChange);
// //     super.dispose();
// //   }

// //   void _onFocusChange() {
// //     if (mounted && widget.focusNode.hasFocus != _hasFocus) {
// //       setState(() {
// //         _hasFocus = widget.focusNode.hasFocus;
// //       });
// //     }
// //   }

// //   KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
// //     if (event is RawKeyDownEvent) {
// //       if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) {
// //         widget.onTap();
// //         return KeyEventResult.handled;
// //       }
// //       if (widget.isFirst && event.logicalKey == LogicalKeyboardKey.arrowLeft) {
// //         return KeyEventResult.handled;
// //       }
// //       if (widget.isLast && event.logicalKey == LogicalKeyboardKey.arrowRight) {
// //         return KeyEventResult.handled;
// //       }
// //     }
// //     return KeyEventResult.ignored;
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];

// //     return Focus(
// //       focusNode: widget.focusNode,
// //       onKey: _handleKeyEvent,
// //       child: GestureDetector(
// //         onTap: widget.onTap,
// //         child: Container(
// //           width: bannerwdt ,
// //           margin: const EdgeInsets.only(right: 12.0),
// //           child: Column(
// //             crossAxisAlignment: CrossAxisAlignment.start,
// //             children: [
// //               Expanded(
// //                 child: Container(
// //                   decoration: BoxDecoration(
// //                     borderRadius: BorderRadius.circular(8.0),
// //                     border: _hasFocus
// //                         ? Border.all(color: focusColor, width: 3)
// //                         : Border.all(color: Colors.transparent, width: 3),
// //                     boxShadow: _hasFocus
// //                         ? [BoxShadow(color: focusColor.withOpacity(0.5), blurRadius: 12, spreadRadius: 1)]
// //                         : [],
// //                   ),
// //                   child: ClipRRect(
// //                     borderRadius: BorderRadius.circular(6.0),
// //                     child: Stack(
// //                       fit: StackFit.expand,
// //                       children: [
// //                         _buildBannerImage(),
// //                         if (widget.movie.contentType == 2)
// //                           Positioned(
// //                             bottom: 8,
// //                             left: 8,
// //                             child: Container(
// //                               padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
// //                               decoration: BoxDecoration(
// //                                 color: ProfessionalColors.accentPurple.withOpacity(0.9),
// //                                 borderRadius: BorderRadius.circular(4.0),
// //                               ),
// //                               child: const Text(
// //                                 'Web Series',
// //                                 style: TextStyle(
// //                                   color: ProfessionalColors.textPrimary,
// //                                   fontSize: 10,
// //                                   fontWeight: FontWeight.bold,
// //                                 ),
// //                               ),
// //                             ),
// //                           ),
// //                         if (_hasFocus)
// //                           Positioned (
// //                             left: 5,
// //                             top: 5,
// //                             child: Container(
// //                               color: Colors.black.withOpacity(0.4),
// //                               child: Icon(Icons.play_circle_filled_outlined, color: focusColor, size: 40),
// //                             ),
// //                           ),
// //                         Positioned(
// //                           top: 5, right: 5,
// //                           child: CircleAvatar(
// //                             radius: 12, backgroundImage: NetworkImage(widget.logoUrl), backgroundColor: Colors.black54,
// //                           ),
// //                         ),
// //                       ],
// //                     ),
// //                   ),
// //                 ),
// //               ),
// //               Padding(
// //                 padding: const EdgeInsets.only(top: 2.0, left: 2.0, right: 2.0),
// //                 child: Text(
// //                   widget.movie.name,
// //                   style:  TextStyle(color: _hasFocus ? focusColor : ProfessionalColors.textSecondary, fontSize: 14),
// //                   maxLines: 1,
// //                   overflow: TextOverflow.ellipsis,
// //                 ),
// //               ),
// //             ],
// //           ),
// //         ),
// //       ),
// //     );
// //   }

// //   Widget _buildBannerImage() {
// //     return displayImage(
// //       widget.movie.banner ?? '',
// //       fit: BoxFit.cover,
// //     );
// //   }
// // }

// // class ViewAllCard extends StatefulWidget {
// //   final FocusNode focusNode;
// //   final List<Color> focusColors;
// //   final int uniqueIndex;
// //   final VoidCallback onTap;

// //   const ViewAllCard({
// //     super.key,
// //     required this.focusNode,
// //     required this.focusColors,
// //     required this.uniqueIndex,
// //     required this.onTap,
// //   });

// //   @override
// //   State<ViewAllCard> createState() => _ViewAllCardState();
// // }

// // class _ViewAllCardState extends State<ViewAllCard> {
// //   bool _hasFocus = false;

// //   @override
// //   void initState() {
// //     super.initState();
// //     widget.focusNode.addListener(_onFocusChange);
// //   }

// //   @override
// //   void dispose() {
// //     widget.focusNode.removeListener(_onFocusChange);
// //     super.dispose();
// //   }

// //   void _onFocusChange() {
// //     if (mounted && widget.focusNode.hasFocus != _hasFocus) {
// //       setState(() {
// //         _hasFocus = widget.focusNode.hasFocus;
// //       });
// //     }
// //   }

// //   KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
// //     if (event is RawKeyDownEvent) {
// //       if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) {
// //         widget.onTap();
// //         return KeyEventResult.handled;
// //       }
// //       if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
// //         return KeyEventResult.handled;
// //       }
// //     }
// //     return KeyEventResult.ignored;
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];
    
// //     return Focus(
// //       focusNode: widget.focusNode,
// //       onKey: _handleKeyEvent,
// //       child: GestureDetector(
// //         onTap: widget.onTap,
// //         child: Container(
// //           width: bannerwdt,
// //           margin: const EdgeInsets.only(right: 12.0),
// //           decoration: BoxDecoration(
// //             borderRadius: BorderRadius.circular(10.0),
// //             border: _hasFocus
// //                 ? Border.all(color: focusColor, width: 3)
// //                 : Border.all(color: Colors.transparent, width: 3),
// //             boxShadow: _hasFocus
// //                 ? [BoxShadow(color: ProfessionalColors.focusGlow.withOpacity(0.7), blurRadius: 12, spreadRadius: 1)]
// //                 : [],
// //           ),
// //           child: ClipRRect(
// //             borderRadius: BorderRadius.circular(8.0),
// //             child: Container(
// //               color: ProfessionalColors.cardDark,
// //               child: Center(
// //                 child: Column(
// //                   mainAxisAlignment: MainAxisAlignment.center,
// //                   children: [
// //                     Icon(Icons.arrow_forward, color: _hasFocus ? focusColor : Colors.white70, size: 32),
// //                     const SizedBox(height: 8),
// //                     Text(
// //                       "View All",
// //                       style: TextStyle(color: _hasFocus ? focusColor : Colors.white70, fontWeight: FontWeight.bold),
// //                     ),
// //                   ],
// //                 ),
// //               ),
// //             ),
// //           ),
// //         ),
// //       ),
// //     );
// //   }
// // }

// // class GenreGridScreen extends StatefulWidget {
// //   final String genre;
// //   final String tvChannelId;
// //   final String logoUrl;

// //   const GenreGridScreen({
// //     super.key,
// //     required this.genre,
// //     required this.tvChannelId,
// //     required this.logoUrl,
// //   });

// //   @override
// //   State<GenreGridScreen> createState() => _GenreGridScreenState();
// // }

// // class _GenreGridScreenState extends State<GenreGridScreen> {
// //   bool _isLoading = true;
// //   String? _error;
// //   List<Movie> _movies = [];
// //   List<FocusNode> _focusNodes = [];
// //   List<GlobalKey> _cardKeys = [];
// //   bool _isVideoLoading = false;
  
// //   String _focusedMovieName = '';

// //   final List<Color> _focusColors = [
// //     ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen,
// //     ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed,
// //   ];

// //   @override
// //   void initState() {
// //     super.initState();
// //     _focusedMovieName = widget.genre;
// //     _fetchGridData();
// //   }

// //   @override
// //   void dispose() {
// //     for (var node in _focusNodes) {
// //       node.dispose();
// //     }
// //     super.dispose();
// //   }
  
// //   void _onItemFocusChange(int index) {
// //     if (index >= 0 && index < _movies.length) {
// //       if (mounted) {
// //         setState(() {
// //           _focusedMovieName = _movies[index].name;
// //         });
// //       }
// //     }

// //     if (index < 0 || index >= _cardKeys.length) return;
// //     final context = _cardKeys[index].currentContext;
// //     if (context != null) {
// //       Scrollable.ensureVisible(
// //         context,
// //         duration: const Duration(milliseconds: 350),
// //         curve: Curves.easeOut,
// //         alignment: 0.15,
// //       );
// //     }
// //   }

// //   Future<void> _fetchGridData() async {
// //     try {
// //       final prefs = await SharedPreferences.getInstance();
// //       final authKey = prefs.getString('result_auth_key') ?? '';

// //       final moviesResponse = await http.post(
// //         Uri.parse(
// //           'https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew'),
// //         headers: {
// //           'auth-key': authKey, 'domain': 'coretechinfo.com',
// //           'Accept': 'application/json', 'Content-Type': 'application/json',
// //         },
// //         body: json
// //             .encode({"genre": widget.genre, "network_id": widget.tvChannelId}),
// //       );

// //       if (moviesResponse.statusCode == 200) {
// //         final movieData =
// //             MovieResponse.fromJson(json.decode(moviesResponse.body));
// //         if (movieData.status) {
// //           _movies = movieData.data.where((movie) => movie.status == 1).toList();
// //           _focusNodes = List.generate(_movies.length, (index) => FocusNode());
// //           _cardKeys = List.generate(_movies.length, (index) => GlobalKey());

// //           for (int i = 0; i < _focusNodes.length; i++) {
// //             _focusNodes[i].addListener(() {
// //               if (_focusNodes[i].hasFocus) {
// //                 _onItemFocusChange(i);
// //               }
// //             });
// //           }
// //         }
// //       } else {
// //         throw Exception('Failed to load content for ${widget.genre}');
// //       }
// //     } catch (e) {
// //       _error = e.toString();
// //     } finally {
// //       if (mounted) {
// //         setState(() {
// //           _isLoading = false;
// //         });
// //         Future.delayed(const Duration(milliseconds: 200), () {
// //           if (_focusNodes.isNotEmpty) {
// //             _focusNodes.first.requestFocus();
// //           }
// //         });
// //       }
// //     }
// //   }

// //   Future<void> _playContent(Movie content) async {
// //     if (_isVideoLoading || !mounted) return;
// //     setState(() { _isVideoLoading = true; });
// //     try {
// //       String playableUrl = content.getPlayableUrl();

// //       try {
// //         // await HistoryService.updateUserHistory(...);
// //       } catch (e) { print("History update failed, but proceeding to play. Error: $e"); }

// //       if (content.contentType == 2) {
// //         await Navigator.push(
// //           context,
// //           MaterialPageRoute(
// //             builder: (context) => WebSeriesDetailsPage(
// //               id: content.id, banner: content.banner ?? '', poster: content.poster ?? '',
// //               logo: widget.logoUrl, name: content.name, updatedAt: content.updatedAt ?? '',
// //             ),
// //           ),
// //         );
// //         return;
// //       }

// //       if (playableUrl.isEmpty) { throw Exception('No video URL found'); }

// //       if (!mounted) return;

// //       if (content.sourceType == 'YoutubeLive' ||
// //           (content.youtubeTrailer != null &&
// //               content.youtubeTrailer!.isNotEmpty)) {
// //         final deviceInfo = context.read<DeviceInfoProvider>();
// //         if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
// //           await Navigator.push(
// //               context,
// //               MaterialPageRoute(
// //                   builder: (context) =>
// //                       YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
// //         } else {
// //           await Navigator.push(
// //               context,
// //               MaterialPageRoute(
// //                   builder: (context) => CustomYoutubePlayer(
// //                       videoData: VideoData(
// //                         id: content.id.toString(), title: content.name, youtubeUrl: playableUrl,
// //                         thumbnail: content.poster ?? content.banner ?? '',
// //                         description: content.description ?? '',
// //                       ),
// //                       playlist: [],
// //                     )));
// //         }
// //       } else {
// //         await Navigator.push(
// //           context,
// //           MaterialPageRoute(
// //             builder: (context) => VideoScreen(
// //               videoUrl: playableUrl, bannerImageUrl: content.poster ?? content.banner ?? '',
// //               videoId: content.id, name: content.name, updatedAt: content.updatedAt ?? '',
// //               source: 'isVod', channelList: [], liveStatus: false,
// //             ),
// //           ),
// //         );
// //       }
// //     } catch (e) {
// //       if (mounted) {
// //         ScaffoldMessenger.of(context).showSnackBar(
// //           SnackBar(content: Text('Error: ${e.toString()}')),
// //         );
// //       }
// //     } finally {
// //       if (mounted) {
// //         setState(() { _isVideoLoading = false; });
// //       }
// //     }
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     return Scaffold(
// //       backgroundColor: ProfessionalColors.primaryDark,
// //       body: Stack(
// //         children: [
// //           Container(
// //             decoration: const BoxDecoration(
// //               gradient: LinearGradient(
// //                 colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)],
// //                 begin: Alignment.topCenter, end: Alignment.bottomCenter,
// //               ),
// //             ),
// //           ),
// //           CustomScrollView(
// //             slivers: [
// //               SliverPadding(padding: EdgeInsets.only(top: 100.0)),
// //               _isLoading
// //                 ? const SliverFillRemaining(child: Center(child: CircularProgressIndicator()))
// //                 : _error != null
// //                   ? SliverFillRemaining(child: Center(child: Text('Error: $_error')))
// //                   : _buildContentGrid(),
// //             ]
// //           ),
// //             Positioned(
// //             top: 0,
// //             left: 0,
// //             right: 0,
// //             child: _buildBeautifulAppBar(),
// //           ),
// //           if (_isVideoLoading)
// //             Container(
// //               color: Colors.black.withOpacity(0.7),
// //               child: const Center(
// //                   child: CircularProgressIndicator(
// //                 valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
// //               )),
// //             ),
// //         ],
// //       ),
// //     );
// //   }

// //   Widget _buildBeautifulAppBar() {
// //     return Container(
// //       decoration: BoxDecoration(
// //         gradient: LinearGradient(
// //           begin: Alignment.topCenter,
// //           end: Alignment.bottomCenter,
// //           colors: [
// //             ProfessionalColors.primaryDark.withOpacity(0.95),
// //             ProfessionalColors.surfaceDark.withOpacity(0.9),
// //             ProfessionalColors.surfaceDark.withOpacity(0.8),
// //             Colors.transparent,
// //           ],
// //         ),
// //         border: Border(
// //           bottom: BorderSide(
// //             color: ProfessionalColors.accentBlue.withOpacity(0.2),
// //             width: 1,
// //           ),
// //         ),
// //         boxShadow: [
// //           BoxShadow(
// //             color: Colors.black.withOpacity(0.3),
// //             blurRadius: 10,
// //             offset: const Offset(0, 2),
// //           ),
// //         ],
// //       ),
// //       child: ClipRRect(
// //         child: BackdropFilter(
// //           filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
// //           child: Container(
// //               padding: EdgeInsets.only(
// //                 top: MediaQuery.of(context).padding.top + 10,
// //                 left: 20,
// //                 right: 30,
// //                 bottom: 10,
// //               ),
// //               child: Row(
// //                 mainAxisAlignment: MainAxisAlignment.spaceEvenly,
// //                 children: [
// //                   Container(
// //                     decoration: BoxDecoration(
// //                       shape: BoxShape.circle,
// //                       gradient: LinearGradient(
// //                         colors: [
// //                           ProfessionalColors.accentBlue.withOpacity(0.3),
// //                           ProfessionalColors.accentPurple.withOpacity(0.3),
// //                         ],
// //                       ),
// //                     ),
// //                     child: IconButton(
// //                       icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24),
// //                       onPressed: () => Navigator.pop(context),
// //                     ),
// //                   ),
// //                   const SizedBox(width: 16),

// //                   // MODIFIED: Replaced Text with GradientText for the genre title in grid view
// //                   GradientText(
// //                     widget.genre,
// //                     style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22),
// //                     gradient: const LinearGradient(colors: [
// //                       ProfessionalColors.accentPink,
// //                       ProfessionalColors.accentPurple,
// //                       ProfessionalColors.accentBlue,
// //                     ]),
// //                   ),
// //                   const SizedBox(width: 40),
// //                   Expanded(
// //                     child: Text(
// //                       _focusedMovieName,
// //                       textAlign: TextAlign.left,
// //                       style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20),
// //                       overflow: TextOverflow.ellipsis,
// //                     ),
// //                   ),
// //                         Padding(
// //                     padding: const EdgeInsets.only(right: 15.0),
// //                     child: CircleAvatar(
// //                       backgroundImage: NetworkImage(widget.logoUrl),
// //                       radius: 20,
// //                       backgroundColor: Colors.white24,
// //                     ),
// //                   ),
// //                 ],
// //               ),
// //             ),
// //         ),
// //       ),
// //     );
// //   }


// //   Widget _buildContentGrid() {
// //     return SliverPadding(
// //       padding: const EdgeInsets.all(30.0),
// //       sliver: SliverGrid(
// //         gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
// //           crossAxisCount: 6,
// //           childAspectRatio: 1.5,
// //           mainAxisSpacing: 5,
// //           crossAxisSpacing: 5,
// //         ),
// //         delegate: SliverChildBuilderDelegate(
// //           (context, index) {
// //             final movie = _movies[index];
// //             return MovieCard(
// //               key: _cardKeys[index],
// //               movie: movie,
// //               logoUrl: widget.logoUrl,
// //               focusNode: _focusNodes[index],
// //               focusColors: _focusColors,
// //               uniqueIndex: index,
// //               onTap: () => _playContent(movie),
// //             );
// //           },
// //           childCount: _movies.length,
// //         ),
// //       ),
// //     );
// //   }
// // }

// // // ==========================================================
// // // NEW WIDGET: A reusable widget to display text with a gradient fill.
// // // ==========================================================
// // class GradientText extends StatelessWidget {
// //   const GradientText(
// //     this.text, {
// //     super.key,
// //     required this.gradient,
// //     this.style,
// //   });

// //   final String text;
// //   final TextStyle? style;
// //   final Gradient gradient;

// //   @override
// //   Widget build(BuildContext context) {
// //     return ShaderMask(
// //       blendMode: BlendMode.srcIn,
// //       shaderCallback: (bounds) => gradient.createShader(
// //         Rect.fromLTWH(0, 0, bounds.width, bounds.height),
// //       ),
// //       child: Text(text, style: style),
// //     );
// //   }
// // }

// // // ==========================================================
// // // Helper functions (displayImage etc.) - NO CHANGES NEEDED
// // // ==========================================================
// // Uint8List _getImageFromBase64String(String base64String) {
// //   return base64Decode(base64String.split(',').last);
// // }

// // Widget displayImage(
// //   String imageUrl, {
// //   double? width,
// //   double? height,
// //   BoxFit fit = BoxFit.fill,
// // }) {
// //   if (imageUrl.isEmpty || imageUrl == 'localImage') {
// //     return _buildErrorWidget(width, height);
// //   }
// //   if (imageUrl.contains('localhost')) {
// //     return _buildErrorWidget(width, height);
// //   }
// //   if (imageUrl.startsWith('data:image')) {
// //     try {
// //       Uint8List imageBytes = _getImageFromBase64String(imageUrl);
// //       return Image.memory(
// //         imageBytes,
// //         fit: fit,
// //         width: width,
// //         height: height,
// //         errorBuilder: (context, error, stackTrace) {
// //           return _buildErrorWidget(width, height);
// //         },
// //       );
// //     } catch (e) {
// //       return _buildErrorWidget(width, height);
// //     }
// //   } else if (imageUrl.startsWith('http') || imageUrl.startsWith('https')) {
// //     if (imageUrl.toLowerCase().endsWith('.svg')) {
// //       return SvgPicture.network(
// //         imageUrl,
// //         width: width,
// //         height: height,
// //         fit: fit,
// //         placeholderBuilder: (context) {
// //           return _buildLoadingWidget(width, height);
// //         },
// //       );
// //     } else {
// //       return Image.network(
// //         imageUrl,
// //         width: width,
// //         height: height,
// //         fit: fit,
// //         headers: const {
// //           'User-Agent': 'Flutter App',
// //         },
// //         loadingBuilder: (BuildContext context, Widget child,
// //             ImageChunkEvent? loadingProgress) {
// //           if (loadingProgress == null) {
// //             return child;
// //           }
// //           return _buildLoadingWidget(width, height);
// //         },
// //         errorBuilder:
// //             (BuildContext context, Object error, StackTrace? stackTrace) {
// //           return _buildErrorWidget(width, height);
// //         },
// //       );
// //     }
// //   } else {
// //     return _buildErrorWidget(width, height);
// //   }
// // }

// // Widget _buildErrorWidget(double? width, double? height) {
// //   return Container(
// //     decoration: const BoxDecoration(
// //       gradient: LinearGradient(
// //         colors: [
// //           ProfessionalColors.accentGreen,
// //           ProfessionalColors.accentBlue,
// //         ],
// //       ),
// //     ),
// //     child: const Icon(
// //       Icons.broken_image,
// //       color: Colors.white,
// //       size: 24,
// //     ),
// //   );
// // }

// // Widget _buildLoadingWidget(double? width, double? height) {
// //   return SizedBox(
// //     width: width,
// //     height: height,
// //     child: const Center(
// //       child: CircularProgressIndicator(
// //         strokeWidth: 2,
// //         valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
// //       ),
// //     ),
// //   );
// // }






// import 'dart:convert';
// import 'dart:ui';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:flutter/services.dart';
// import 'package:flutter_svg/svg.dart';
// import 'package:http/http.dart' as http;
// import 'package:mobi_tv_entertainment/home_screen_pages/sub_vod_screen/horzontal_vod.dart';
// import 'package:mobi_tv_entertainment/main.dart';
// import 'package:mobi_tv_entertainment/home_screen_pages/webseries_screen/webseries_details_page.dart';
// import 'package:mobi_tv_entertainment/provider/device_info_provider.dart';
// import 'package:mobi_tv_entertainment/services/history_service.dart';
// // import 'package:mobi_tv_entertainment/utils/session_manager.dart'; // Assuming SessionManager exists
// import 'package:mobi_tv_entertainment/video_widget/custom_youtube_player.dart';
// import 'package:mobi_tv_entertainment/video_widget/video_screen.dart';
// import 'package:mobi_tv_entertainment/video_widget/youtube_webview_player.dart';
// import 'package:provider/provider.dart';
// import 'package:shared_preferences/shared_preferences.dart';

// // Professional Color Palette
// class ProfessionalColors {
//   static const primaryDark = Color(0xFF0A0E1A);
//   static const surfaceDark = Color(0xFF1A1D29);
//   static const cardDark = Color(0xFF2A2D3A);
//   static const accentBlue = Color(0xFF3B82F6);
//   static const accentPurple = Color(0xFF8B5CF6);
//   static const accentGreen = Color(0xFF10B981);
//   static const accentRed = Color(0xFFEF4444);
//   static const accentOrange = Color(0xFFF59E0B);
//   static const accentPink = Color(0xFFEC4899);
//   static const textPrimary = Color(0xFFFFFFFF);
//   static const textSecondary = Color(0xFFB3B3B3);
//   static const focusGlow = Color(0xFF60A5FA);
// }

// // Data Models
// class GenreResponse {
//   final bool status;
//   final List<String> genres;
//   GenreResponse({required this.status, required this.genres});
//   factory GenreResponse.fromJson(Map<String, dynamic> json) {
//     return GenreResponse(
//       status: json['status'],
//       genres: List<String>.from(json['genres']),
//     );
//   }
// }

// class MovieResponse {
//   final bool status;
//   final int total;
//   final List<Movie> data;
//   MovieResponse({required this.status, required this.total, required this.data});
//   factory MovieResponse.fromJson(Map<String, dynamic> json) {
//     return MovieResponse(
//       status: json['status']??'',
//       total: json['total']??'',
//       data: (json['data'] as List).map((i) => Movie.fromJson(i)).toList(),
//     );
//   }
// }
// class Movie {
//   final int id;
//   final String name;
//   final String? banner;
//   final String? poster;
//   final String? description;
//   final int? contentType;
//   final String? sourceType;
//   final String? youtubeTrailer;
//   final String? updatedAt;
//   final String? movieUrl;
//   final int? status;

//   Movie({
//     required this.id,
//     required this.name,
//     this.banner,
//     this.poster,
//     this.description,
//     this.contentType,
//     this.sourceType,
//     this.youtubeTrailer,
//     this.updatedAt,
//     this.movieUrl,
//     this.status,
//   });

//   factory Movie.fromJson(Map<String, dynamic> json) {
//     return Movie(
//       id: json['id']??'',
//       name: json['name']??'',
//       banner: json['banner']??'',
//       poster: json['poster']??'',
//       description: json['description']??'',
//       contentType: json['content_type']??'',
//       sourceType: json['source_type']??'',
//       youtubeTrailer: json['youtube_trailer']??'',
//       updatedAt: json['updated_at']??'',
//       movieUrl: json['movie_url']??'',
//       status: json['status']??'',
//     );
//   }

//   Map<String, dynamic> toMap() {
//     return {
//       'id': id, 'name': name, 'banner': banner, 'poster': poster,
//       'description': description, 'content_type': contentType, 'source_type': sourceType,
//       'youtube_trailer': youtubeTrailer, 'updated_at': updatedAt, 'movie_url': movieUrl,
//       'status': status,
//     };
//   }

//   factory Movie.fromMap(Map<String, dynamic> map) {
//     return Movie.fromJson(map);
//   }

//   String getPlayableUrl() {
//     if (sourceType == 'YoutubeLive') {
//       return movieUrl ?? '';
//     }
//     if (youtubeTrailer != null && youtubeTrailer!.isNotEmpty) {
//       return youtubeTrailer!;
//     }
//     return movieUrl ?? '';
//   }
// }

// Future<String> _fetchAndCacheDataIsolate(Map<String, String> params) async {
//   final String tvChannelId = params['tvChannelId']!;
//   final String authKey = params['authKey']!;

//   try {
//     final genresResponse = await http.get(
//       Uri.parse('https://dashboard.cpplayers.com/api/v2/getGenreByContentNetwork/$tvChannelId'),
//       headers: {'auth-key': authKey, 'Accept': 'application/json', 'domain': 'coretechinfo.com'},
//     );

//     if (genresResponse.statusCode != 200) {
//       throw Exception('Failed to load genres in isolate');
//     }
//     final genreData = GenreResponse.fromJson(json.decode(genresResponse.body));
//     if (!genreData.status) {
//       return '';
//     }

//     final genres = genreData.genres;
//     final Map<String, List<Movie>> moviesByGenre = {};

//     for (final genre in genres) {
//       final moviesResponse = await http.post(
//         Uri.parse('https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew?page=1&records=10'),
//         headers: {'auth-key': authKey, 'domain': 'coretechinfo.com', 'Accept': 'application/json', 'Content-Type': 'application/json'},
//         body: json.encode({"genre": genre, "network_id": tvChannelId}),
//       );

//       if (moviesResponse.statusCode == 200) {
//         final movieData = MovieResponse.fromJson(json.decode(moviesResponse.body));
//         if (movieData.status && movieData.data.isNotEmpty) {
//           final activeMovies = movieData.data.where((movie) => movie.status == 1).toList();
//           if (activeMovies.isNotEmpty) {
//             moviesByGenre[genre] = activeMovies;
//           }
//         }
//       }
//     }
    
//     final Map<String, dynamic> serializableData = {
//       'genres': genres,
//       'moviesByGenre': moviesByGenre.map((key, value) => MapEntry(key, value.map((m) => m.toMap()).toList())),
//     };

//     return json.encode(serializableData);
//   } catch (e) {
//     print("Isolate Error: $e");
//     return '';
//   }
// }


// class GenreMoviesScreen extends StatefulWidget {
//   final String tvChannelId;
//   final String logoUrl;
//   final String title;

//   const GenreMoviesScreen({
//     super.key,
//     required this.tvChannelId,
//     required this.logoUrl,
//     required this.title,
//   });

//   @override
//   State<GenreMoviesScreen> createState() => _GenreMoviesScreenState();
// }

// class _GenreMoviesScreenState extends State<GenreMoviesScreen> {
//   bool _isLoading = true;
//   String? _error;
//   List<String> _genres = [];
//   final Map<String, List<Movie>> _moviesByGenre = {};
  
//   final List<List<FocusNode>> _focusNodes = [];
//   final ScrollController _verticalScrollController = ScrollController();
//   final Map<int, ScrollController> _horizontalScrollControllers = {};
//   final List<GlobalKey> _rowKeys = [];
//   final List<List<GlobalKey>> _cardKeys = [];

//   final List<Color> _focusColors = [
//     ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen,
//     ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed,
//   ];
//   final List<Gradient> _genreBackgrounds = const [
//     LinearGradient(colors: [Color(0xFF1A1D29), Color(0xFF0F121E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
//     LinearGradient(colors: [Color(0xFF1C1A29), Color(0xFF110F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
//     LinearGradient(colors: [Color(0xFF1A2129), Color(0xFF0F161E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
//     LinearGradient(colors: [Color(0xFF211A29), Color(0xFF160F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter),
//   ];
//   bool _isVideoLoading = false;
  
//   String _focusedItemName = '';

//   String get _cacheKey => 'genre_movies_cache_${widget.tvChannelId}';

//   @override
//   void initState() {
//     super.initState();
//     _focusedItemName = ''; 
//     _loadInitialData();
//   }
  
//   @override
//   void dispose() {
//     for (var row in _focusNodes) {
//       for (var node in row) {
//         node.dispose();
//       }
//     }
//     _verticalScrollController.dispose();
//     _horizontalScrollControllers.values.forEach((controller) => controller.dispose());
//     super.dispose();
//   }
  
//   Future<void> _loadInitialData() async {
//     final prefs = await SharedPreferences.getInstance();
//     final cachedData = prefs.getString(_cacheKey);

//     if (cachedData != null && cachedData.isNotEmpty) {
//       _parseAndSetState(cachedData);
//       // No need to set isLoading, it will be handled in _parseAndSetState
//     } else {
//       await _fetchDataWithLoading();
//     }
//   }
  
//   Future<void> _refreshDataInBackground() async {
//     try {
//       final prefs = await SharedPreferences.getInstance();
//       final authKey = prefs.getString('result_auth_key') ?? '';

//       final String freshDataJson = await compute(_fetchAndCacheDataIsolate, {
//         'tvChannelId': widget.tvChannelId,
//         'authKey': authKey,
//       });

//       if (freshDataJson.isNotEmpty) {
//         await prefs.setString(_cacheKey, freshDataJson);
//         print("Cache successfully updated in the background.");
//       }
//     } catch (e) {
//       print("Background refresh failed: $e");
//     }
//   }
  
//   Future<void> _fetchDataWithLoading() async {
//     if (mounted) setState(() { _isLoading = true; _error = null; });
//     try {
//       final prefs = await SharedPreferences.getInstance();
//       final authKey = prefs.getString('result_auth_key') ?? '';

//       final String freshDataJson = await _fetchAndCacheDataIsolate({
//         'tvChannelId': widget.tvChannelId,
//         'authKey': authKey,
//       });

//       if (freshDataJson.isNotEmpty) {
//         await prefs.setString(_cacheKey, freshDataJson);
//         _parseAndSetState(freshDataJson);
//       } else {
//         throw Exception('Failed to load data');
//       }
//     } catch (e) {
//       if (mounted) setState(() => _error = e.toString());
//     } finally {
//       if (mounted) setState(() => _isLoading = false);
//     }
//   }

// void _parseAndSetState(String jsonData) {
//   if (!mounted) return;

//   setState(() {
//     _isLoading = true; // Set loading true while parsing

//     final data = json.decode(jsonData) as Map<String, dynamic>;

//     // Clear all previous state
//     _focusNodes.clear();
//     _cardKeys.clear();
//     _rowKeys.clear();
//     _horizontalScrollControllers.values.forEach((c) => c.dispose());
//     _horizontalScrollControllers.clear();

//     final allGenres = List<String>.from(data['genres']);
//     final allMoviesByGenre = (data['moviesByGenre'] as Map<String, dynamic>).map(
//       (key, value) => MapEntry(
//         key,
//         (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList(),
//       ),
//     );

//     final activeGenres = allGenres.where((g) => allMoviesByGenre[g]?.isNotEmpty ?? false).toList();

//     _genres = activeGenres;
//     _moviesByGenre.clear();
//     _moviesByGenre.addAll(allMoviesByGenre);
    
//     _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));

//     for (int i = 0; i < _genres.length; i++) {
//       final genre = _genres[i];
//       final movies = _moviesByGenre[genre] ?? [];

//       int moviesToShow = movies.length > 10 ? 10 : movies.length;
//       int nodeCount = moviesToShow + 1; // +1 for "View All"

//       var rowNodes = List.generate(nodeCount, (_) => FocusNode());
//       var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
//       _cardKeys.add(rowCardKeys);
      
//       _horizontalScrollControllers[i] = ScrollController();

//       for (int j = 0; j < nodeCount; j++) {
//         rowNodes[j].addListener(() {
//           if (rowNodes[j].hasFocus) {
//             _onItemFocusChange(i, j);
//           }
//         });
//       }
//       _focusNodes.add(rowNodes);
//     }

//     _isLoading = false; // Parsing complete
//   });

//   Future.delayed(const Duration(milliseconds: 200), () {
//     if (mounted && _focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
//       _focusNodes.first.first.requestFocus();
//     }
//   });
// }

// void _onItemFocusChange(int genreIndex, int movieIndex) {
//     // *** FIX: Add boundary checks to prevent crashes from rapid input ***
//     if (!mounted || _isLoading || genreIndex < 0 || genreIndex >= _genres.length) {
//         return; // Exit if indices are invalid, data is loading, or widget is disposed
//     }

//     final genre = _genres[genreIndex];
//     final movies = _moviesByGenre[genre] ?? [];

//     int moviesToShow = movies.length > 10 ? 10 : movies.length;
//     int expectedNodeCount = moviesToShow + 1; // +1 for "View All"

//     // *** FIX: Check movieIndex against the expected number of items in the row ***
//     if (movieIndex < 0 || movieIndex >= expectedNodeCount) {
//         return; // Exit if movie index is out of bounds for this specific row
//     }

//     if (movieIndex < moviesToShow) {
//         // It's a movie card
//         final Movie focusedMovie = movies[movieIndex];
//         setState(() => _focusedItemName = focusedMovie.name);
//     } else {
//         // It's the "View All" card
//         setState(() => _focusedItemName = "View All");
//     }

//     _scrollToFocusedVertical(genreIndex);
//     _scrollToFocusedHorizontal(genreIndex, movieIndex);
// }

// void _scrollToFocusedVertical(int genreIndex) {
//     // *** FIX: Add boundary checks ***
//     if (_isLoading || genreIndex < 0 || genreIndex >= _rowKeys.length) return;

//     final rowContext = _rowKeys[genreIndex].currentContext;
//     if (rowContext == null) return;

//     // The rest of the function remains the same...
//     final renderBox = rowContext.findRenderObject() as RenderBox;
//     final rowOffset = renderBox.localToGlobal(Offset.zero);
//     final scrollOffset = _verticalScrollController.offset;
//     const appBarHeight = 100.0;
//     final rowTop = rowOffset.dy + scrollOffset - (screenhgt * 0.5 - appBarHeight * 0.5);

//     _verticalScrollController.animateTo(
//         rowTop.clamp(0.0, _verticalScrollController.position.maxScrollExtent),
//         duration: const Duration(milliseconds: 350),
//         curve: Curves.easeOut,
//     );
// }

// void _scrollToFocusedHorizontal(int genreIndex, int movieIndex) {
//     // *** FIX: Add boundary checks ***
//     if (_isLoading || genreIndex < 0 || genreIndex >= _horizontalScrollControllers.length || genreIndex >= _cardKeys.length) return;
//     if (movieIndex < 0 || movieIndex >= _cardKeys[genreIndex].length) return;

//     final scrollController = _horizontalScrollControllers[genreIndex];
//     if (scrollController == null || !scrollController.hasClients) return;
    
//     final cardContext = _cardKeys[genreIndex][movieIndex].currentContext;
//     if (cardContext == null) return;
    
//     // The rest of the function remains the same...
//     final renderBox = cardContext.findRenderObject() as RenderBox;
//     final cardOffset = renderBox.localToGlobal(Offset.zero, ancestor: scrollController.position.context.storageContext.findRenderObject());
//     double targetOffset = scrollController.offset + cardOffset.dx - 40;
//     targetOffset = targetOffset.clamp(0.0, scrollController.position.maxScrollExtent);
    
//     scrollController.animateTo(
//         targetOffset,
//         duration: const Duration(milliseconds: 300),
//         curve: Curves.easeOut,
//     );
// }

  
//   Future<void> _playContent(Movie content) async {
//     if (_isVideoLoading || !mounted) return;
//     setState(() { _isVideoLoading = true; });
//     try {
//       String playableUrl = content.getPlayableUrl();
//       try {
//         // await HistoryService.updateUserHistory(...);
//       } catch (e) { print("History update failed, but proceeding to play. Error: $e"); }
//       if (content.contentType == 2) {
//         await Navigator.push(context, MaterialPageRoute(builder: (context) => WebSeriesDetailsPage(
//             id: content.id, banner: content.banner ?? '', poster: content.poster ?? '',
//             logo: widget.logoUrl, name: content.name, updatedAt: content.updatedAt ?? '',
//           ),),);
//         return;
//       }
//       if (playableUrl.isEmpty) { throw Exception('No video URL found'); }
//       if (!mounted) return;
//       if (content.sourceType == 'YoutubeLive' || (content.youtubeTrailer != null && content.youtubeTrailer!.isNotEmpty)) {
//         final deviceInfo = context.read<DeviceInfoProvider>();
//         if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
//           await Navigator.push(context, MaterialPageRoute(builder: (context) => YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
//         } else {
//           await Navigator.push(context, MaterialPageRoute(builder: (context) => CustomYoutubePlayer(
//               videoData: VideoData(
//                 id: content.id.toString(), title: content.name, youtubeUrl: playableUrl,
//                 thumbnail: content.poster ?? content.banner ?? '', description: content.description ?? '',
//               ), playlist: [],
//             )));
//         }
//       } else {
//         await Navigator.push(context, MaterialPageRoute( builder: (context) => VideoScreen(
//             videoUrl: playableUrl, bannerImageUrl: content.poster ?? content.banner ?? '',
//             videoId: content.id, name: content.name, updatedAt: content.updatedAt ?? '',
//             source: 'isVod', channelList: [], liveStatus: false,
//           ),),);
//       }
//     } catch (e) {
//       if (mounted) { ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}'))); }
//     } finally {
//       if (mounted) { setState(() { _isVideoLoading = false; }); }
//     }
//   }

//   void _navigateToGridPage(String genre) {
//     Navigator.push(context, MaterialPageRoute(builder: (context) => GenreGridScreen(
//       genre: genre, tvChannelId: widget.tvChannelId, logoUrl: widget.logoUrl,
//     ),),);
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       backgroundColor: ProfessionalColors.primaryDark,
//       body: Stack(
//         children: [
//           Container(
//             decoration: const BoxDecoration(
//               gradient: LinearGradient(
//                 colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)],
//                 begin: Alignment.topCenter,
//                 end: Alignment.bottomCenter,
//               ),
//             ),
//           ),
//           CustomScrollView(
//             controller: _verticalScrollController,
//             slivers: [
//               SliverPadding(padding: EdgeInsets.only(top: 100.0)),
//               _isLoading
//                   ? const SliverFillRemaining(
//                       child: Center(child: CircularProgressIndicator()))
//                   : _error != null
//                       ? SliverFillRemaining(
//                           child: Center(child: Text('Error: $_error')))
//                       : _buildGenresList(),
//             ],
//           ),
//           Positioned(
//             top: 0,
//             left: 0,
//             right: 0,
//             child: _buildBeautifulAppBar(),
//           ),
//           if (_isVideoLoading)
//             Container(
//               color: Colors.black.withOpacity(0.7),
//               child: const Center(
//                   child: CircularProgressIndicator(
//                       valueColor: AlwaysStoppedAnimation<Color>(Colors.white))),
//             ),
//         ],
//       ),
//     );
//   }

//   Widget _buildBeautifulAppBar() {
//     return Container(
//       decoration: BoxDecoration(
//         gradient: LinearGradient(
//           begin: Alignment.topCenter,
//           end: Alignment.bottomCenter,
//           colors: [
//             ProfessionalColors.primaryDark.withOpacity(0.95),
//             ProfessionalColors.surfaceDark.withOpacity(0.9),
//             ProfessionalColors.surfaceDark.withOpacity(0.8),
//             Colors.transparent,
//           ],
//         ),
//         border: Border(
//           bottom: BorderSide(
//             color: ProfessionalColors.accentBlue.withOpacity(0.2),
//             width: 1,
//           ),
//         ),
//         boxShadow: [
//           BoxShadow(
//             color: Colors.black.withOpacity(0.3),
//             blurRadius: 10,
//             offset: const Offset(0, 2),
//           ),
//         ],
//       ),
//       child: ClipRRect(
//         child: BackdropFilter(
//           filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
//           child: Container(
//             padding: EdgeInsets.only(
//               top: MediaQuery.of(context).padding.top + 10,
//               left: 20,
//               right: 30,
//               bottom: 10,
//             ),
//             child: Row(
//               children: [
//                 Container(
//                   decoration: BoxDecoration(
//                     shape: BoxShape.circle,
//                     gradient: LinearGradient(
//                       colors: [
//                         ProfessionalColors.accentBlue.withOpacity(0.3),
//                         ProfessionalColors.accentPurple.withOpacity(0.3),
//                       ],
//                     ),
//                   ),
//                   child: IconButton(
//                     icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24),
//                     onPressed: () => Navigator.pop(context),
//                   ),
//                 ),
//                 const SizedBox(width: 16),
//                 GradientText(
//                   widget.title,
//                   style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22),
//                   gradient: const LinearGradient(colors: [
//                     ProfessionalColors.accentPink,
//                     ProfessionalColors.accentPurple,
//                     ProfessionalColors.accentBlue,
//                   ]),
//                 ),
//                 const SizedBox(width: 40),
//                 Expanded(
//                   child: Text(
//                     _focusedItemName,
//                     textAlign: TextAlign.left,
//                     style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20),
//                     overflow: TextOverflow.ellipsis,
//                   ),
//                 ),
//                 Padding(
//                   padding: const EdgeInsets.only(right: 15.0),
//                   child: CircleAvatar(
//                     backgroundImage: NetworkImage(widget.logoUrl),
//                     radius: 20,
//                     backgroundColor: Colors.white24,
//                   ),
//                 ),
//               ],
//             ),
//           ),
//         ),
//       ),
//     );
//   }

// Widget _buildGenresList() {
//   return SliverList(
//     delegate: SliverChildBuilderDelegate(
//       (context, index) {
//         final genre = _genres[index];
//         final movies = _moviesByGenre[genre] ?? [];

//         final int moviesToShow = movies.length > 10 ? 10 : movies.length;
//         final int itemCount = moviesToShow + 1;

//         return Container(
//           key: _rowKeys[index],
//           decoration: BoxDecoration(gradient: _genreBackgrounds[index % _genreBackgrounds.length]),
//           padding: const EdgeInsets.symmetric(vertical: 5.0),
//           child: Column(
//             crossAxisAlignment: CrossAxisAlignment.start,
//             children: [
//               Padding(
//                 padding: const EdgeInsets.only(left: 30.0, bottom: 5.0),
//                 child: GradientText(
//                   genre,
//                   style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, letterSpacing: 1.2),
//                   gradient: const LinearGradient(
//                     colors: [
//                       ProfessionalColors.accentGreen,
//                       ProfessionalColors.accentOrange,
//                       ProfessionalColors.accentPink,
//                     ],
//                     begin: Alignment.topLeft,
//                     end: Alignment.bottomRight,
//                   ),
//                 ),
//               ),
//               SizedBox(
//                 height: bannerhgt + 25,
//                 child: ListView.builder(
//                   controller: _horizontalScrollControllers[index],
//                   scrollDirection: Axis.horizontal,
//                   itemCount: itemCount,
//                   padding: const EdgeInsets.symmetric(horizontal: 30.0),
//                   itemBuilder: (context, movieIndex) {
//                     if (movieIndex == moviesToShow) {
//                       return ViewAllCard(
//                         key: _cardKeys[index][movieIndex],
//                         focusNode: _focusNodes[index][movieIndex],
//                         focusColors: _focusColors,
//                         uniqueIndex: index * 10 + movieIndex,
//                         onTap: () => _navigateToGridPage(genre),
//                       );
//                     }
                    
//                     final movie = movies[movieIndex];
//                     return MovieCard(
//                       key: _cardKeys[index][movieIndex],
//                       movie: movie,
//                       logoUrl: widget.logoUrl,
//                       focusNode: _focusNodes[index][movieIndex],
//                       focusColors: _focusColors,
//                       uniqueIndex: index * 10 + movieIndex,
//                       onTap: () => _playContent(movie),
//                       isFirst: movieIndex == 0,
//                       isLast: false,
//                     );
//                   },
//                 ),
//               ),
//             ],
//           ),
//         );
//       },
//       childCount: _genres.length,
//     ),
//   );
// }
// }

// // ==========================================================
// // MOVIE CARD WIDGET - NO CHANGES
// // ==========================================================
// class MovieCard extends StatefulWidget {
//   final Movie movie;
//   final String logoUrl;
//   final FocusNode focusNode;
//   final List<Color> focusColors;
//   final int uniqueIndex;
//   final VoidCallback onTap;
//   final bool isFirst;
//   final bool isLast;

//   const MovieCard({
//     super.key,
//     required this.movie,
//     required this.logoUrl,
//     required this.focusNode,
//     required this.focusColors,
//     required this.uniqueIndex,
//     required this.onTap,
//     this.isFirst = false,
//     this.isLast = false,
//   });

//   @override
//   State<MovieCard> createState() => _MovieCardState();
// }

// class _MovieCardState extends State<MovieCard> {
//   bool _hasFocus = false;

//   @override
//   void initState() {
//     super.initState();
//     widget.focusNode.addListener(_onFocusChange);
//   }

//   @override
//   void dispose() {
//     widget.focusNode.removeListener(_onFocusChange);
//     super.dispose();
//   }

//   void _onFocusChange() {
//     if (mounted && widget.focusNode.hasFocus != _hasFocus) {
//       setState(() {
//         _hasFocus = widget.focusNode.hasFocus;
//       });
//     }
//   }

//   KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
//     if (event is RawKeyDownEvent) {
//       if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) {
//         widget.onTap();
//         return KeyEventResult.handled;
//       }
//       if (widget.isFirst && event.logicalKey == LogicalKeyboardKey.arrowLeft) {
//         return KeyEventResult.handled;
//       }
//       if (widget.isLast && event.logicalKey == LogicalKeyboardKey.arrowRight) {
//         return KeyEventResult.handled;
//       }
//     }
//     return KeyEventResult.ignored;
//   }

//   @override
//   Widget build(BuildContext context) {
//     final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];

//     return Focus(
//       focusNode: widget.focusNode,
//       onKey: _handleKeyEvent,
//       child: GestureDetector(
//         onTap: widget.onTap,
//         child: Container(
//           width: bannerwdt ,
//           margin: const EdgeInsets.only(right: 12.0),
//           child: Column(
//             crossAxisAlignment: CrossAxisAlignment.start,
//             children: [
//               Expanded(
//                 child: Container(
//                   decoration: BoxDecoration(
//                     borderRadius: BorderRadius.circular(8.0),
//                     border: _hasFocus
//                         ? Border.all(color: focusColor, width: 3)
//                         : Border.all(color: Colors.transparent, width: 3),
//                     boxShadow: _hasFocus
//                         ? [BoxShadow(color: focusColor.withOpacity(0.5), blurRadius: 12, spreadRadius: 1)]
//                         : [],
//                   ),
//                   child: ClipRRect(
//                     borderRadius: BorderRadius.circular(6.0),
//                     child: Stack(
//                       fit: StackFit.expand,
//                       children: [
//                         _buildBannerImage(),
//                         if (widget.movie.contentType == 2)
//                           Positioned(
//                             bottom: 8,
//                             left: 8,
//                             child: Container(
//                               padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
//                               decoration: BoxDecoration(
//                                 color: ProfessionalColors.accentPurple.withOpacity(0.9),
//                                 borderRadius: BorderRadius.circular(4.0),
//                               ),
//                               child: const Text(
//                                 'Web Series',
//                                 style: TextStyle(
//                                   color: ProfessionalColors.textPrimary,
//                                   fontSize: 10,
//                                   fontWeight: FontWeight.bold,
//                                 ),
//                               ),
//                             ),
//                           ),
//                         if (_hasFocus)
//                           Positioned (
//                             left: 5,
//                             top: 5,
//                             child: Container(
//                               color: Colors.black.withOpacity(0.4),
//                               child: Icon(Icons.play_circle_filled_outlined, color: focusColor, size: 40),
//                             ),
//                           ),
//                         Positioned(
//                           top: 5, right: 5,
//                           child: CircleAvatar(
//                             radius: 12, backgroundImage: NetworkImage(widget.logoUrl), backgroundColor: Colors.black54,
//                           ),
//                         ),
//                       ],
//                     ),
//                   ),
//                 ),
//               ),
//               Padding(
//                 padding: const EdgeInsets.only(top: 2.0, left: 2.0, right: 2.0),
//                 child: Text(
//                   widget.movie.name,
//                   style:  TextStyle(color: _hasFocus ? focusColor : ProfessionalColors.textSecondary, fontSize: 14),
//                   maxLines: 1,
//                   overflow: TextOverflow.ellipsis,
//                 ),
//               ),
//             ],
//           ),
//         ),
//       ),
//     );
//   }

//   Widget _buildBannerImage() {
//     return displayImage(
//       widget.movie.banner ?? '',
//       fit: BoxFit.cover,
//     );
//   }
// }

// // ==========================================================
// // VIEW ALL CARD WIDGET - NO CHANGES
// // ==========================================================
// class ViewAllCard extends StatefulWidget {
//   final FocusNode focusNode;
//   final List<Color> focusColors;
//   final int uniqueIndex;
//   final VoidCallback onTap;

//   const ViewAllCard({
//     super.key,
//     required this.focusNode,
//     required this.focusColors,
//     required this.uniqueIndex,
//     required this.onTap,
//   });

//   @override
//   State<ViewAllCard> createState() => _ViewAllCardState();
// }

// class _ViewAllCardState extends State<ViewAllCard> {
//   bool _hasFocus = false;

//   @override
//   void initState() {
//     super.initState();
//     widget.focusNode.addListener(_onFocusChange);
//   }

//   @override
//   void dispose() {
//     widget.focusNode.removeListener(_onFocusChange);
//     super.dispose();
//   }

//   void _onFocusChange() {
//     if (mounted && widget.focusNode.hasFocus != _hasFocus) {
//       setState(() {
//         _hasFocus = widget.focusNode.hasFocus;
//       });
//     }
//   }

//   KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
//     if (event is RawKeyDownEvent) {
//       if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) {
//         widget.onTap();
//         return KeyEventResult.handled;
//       }
//       if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
//         return KeyEventResult.handled;
//       }
//     }
//     return KeyEventResult.ignored;
//   }

//   @override
//   Widget build(BuildContext context) {
//     final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];
    
//     return Focus(
//       focusNode: widget.focusNode,
//       onKey: _handleKeyEvent,
//       child: GestureDetector(
//         onTap: widget.onTap,
//         child: Container(
//           width: bannerwdt,
//           margin: const EdgeInsets.only(right: 12.0),
//           decoration: BoxDecoration(
//             borderRadius: BorderRadius.circular(10.0),
//             border: _hasFocus
//                 ? Border.all(color: focusColor, width: 3)
//                 : Border.all(color: Colors.transparent, width: 3),
//             boxShadow: _hasFocus
//                 ? [BoxShadow(color: ProfessionalColors.focusGlow.withOpacity(0.7), blurRadius: 12, spreadRadius: 1)]
//                 : [],
//           ),
//           child: ClipRRect(
//             borderRadius: BorderRadius.circular(8.0),
//             child: Container(
//               color: ProfessionalColors.cardDark,
//               child: Center(
//                 child: Column(
//                   mainAxisAlignment: MainAxisAlignment.center,
//                   children: [
//                     Icon(Icons.arrow_forward, color: _hasFocus ? focusColor : Colors.white70, size: 32),
//                     const SizedBox(height: 8),
//                     Text(
//                       "View All",
//                       style: TextStyle(color: _hasFocus ? focusColor : Colors.white70, fontWeight: FontWeight.bold),
//                     ),
//                   ],
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//     );
//   }
// }

// // ==========================================================
// // GENRE GRID SCREEN - UPDATED WITH SAFETY CHECKS
// // ==========================================================
// class GenreGridScreen extends StatefulWidget {
//   final String genre;
//   final String tvChannelId;
//   final String logoUrl;

//   const GenreGridScreen({
//     super.key,
//     required this.genre,
//     required this.tvChannelId,
//     required this.logoUrl,
//   });

//   @override
//   State<GenreGridScreen> createState() => _GenreGridScreenState();
// }

// class _GenreGridScreenState extends State<GenreGridScreen> {
//   bool _isLoading = true;
//   String? _error;
//   List<Movie> _movies = [];
//   List<FocusNode> _focusNodes = [];
//   List<GlobalKey> _cardKeys = [];
//   bool _isVideoLoading = false;
  
//   String _focusedMovieName = '';

//   final List<Color> _focusColors = [
//     ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen,
//     ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed,
//   ];

//   @override
//   void initState() {
//     super.initState();
//     _focusedMovieName = widget.genre;
//     _fetchGridData();
//   }

//   @override
//   void dispose() {
//     for (var node in _focusNodes) {
//       node.dispose();
//     }
//     super.dispose();
//   }
  
// void _onItemFocusChange(int index) {
//     // *** FIX: Add boundary checks for safety ***
//     if (!mounted || _isLoading || index < 0 || index >= _movies.length || index >= _cardKeys.length) {
//         return;
//     }

//     setState(() {
//         _focusedMovieName = _movies[index].name;
//     });

//     final context = _cardKeys[index].currentContext;
//     if (context != null) {
//         Scrollable.ensureVisible(
//             context,
//             duration: const Duration(milliseconds: 350),
//             curve: Curves.easeOut,
//             alignment: 0.15,
//         );
//     }
// }

//   Future<void> _fetchGridData() async {
//     try {
//       final prefs = await SharedPreferences.getInstance();
//       final authKey = prefs.getString('result_auth_key') ?? '';

//       final moviesResponse = await http.post(
//         Uri.parse(
//           'https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew'),
//         headers: {
//           'auth-key': authKey, 'domain': 'coretechinfo.com',
//           'Accept': 'application/json', 'Content-Type': 'application/json',
//         },
//         body: json
//             .encode({"genre": widget.genre, "network_id": widget.tvChannelId}),
//       );

//       if (moviesResponse.statusCode == 200) {
//         final movieData =
//             MovieResponse.fromJson(json.decode(moviesResponse.body));
//         if (movieData.status) {
//           _movies = movieData.data.where((movie) => movie.status == 1).toList();
//           _focusNodes = List.generate(_movies.length, (index) => FocusNode());
//           _cardKeys = List.generate(_movies.length, (index) => GlobalKey());

//           for (int i = 0; i < _focusNodes.length; i++) {
//             _focusNodes[i].addListener(() {
//               if (_focusNodes[i].hasFocus) {
//                 _onItemFocusChange(i);
//               }
//             });
//           }
//         }
//       } else {
//         throw Exception('Failed to load content for ${widget.genre}');
//       }
//     } catch (e) {
//       _error = e.toString();
//     } finally {
//       if (mounted) {
//         setState(() {
//           _isLoading = false;
//         });
//         Future.delayed(const Duration(milliseconds: 200), () {
//           if (mounted && _focusNodes.isNotEmpty) {
//             _focusNodes.first.requestFocus();
//           }
//         });
//       }
//     }
//   }

//   Future<void> _playContent(Movie content) async {
//     if (_isVideoLoading || !mounted) return;
//     setState(() { _isVideoLoading = true; });
//     try {
//       String playableUrl = content.getPlayableUrl();

//       try {
//         // await HistoryService.updateUserHistory(...);
//       } catch (e) { print("History update failed, but proceeding to play. Error: $e"); }

//       if (content.contentType == 2) {
//         await Navigator.push(
//           context,
//           MaterialPageRoute(
//             builder: (context) => WebSeriesDetailsPage(
//               id: content.id, banner: content.banner ?? '', poster: content.poster ?? '',
//               logo: widget.logoUrl, name: content.name, updatedAt: content.updatedAt ?? '',
//             ),
//           ),
//         );
//         return;
//       }

//       if (playableUrl.isEmpty) { throw Exception('No video URL found'); }

//       if (!mounted) return;

//       if (content.sourceType == 'YoutubeLive' ||
//           (content.youtubeTrailer != null &&
//               content.youtubeTrailer!.isNotEmpty)) {
//         final deviceInfo = context.read<DeviceInfoProvider>();
//         if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
//           await Navigator.push(
//               context,
//               MaterialPageRoute(
//                   builder: (context) =>
//                       YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
//         } else {
//           await Navigator.push(
//               context,
//               MaterialPageRoute(
//                   builder: (context) => CustomYoutubePlayer(
//                       videoData: VideoData(
//                         id: content.id.toString(), title: content.name, youtubeUrl: playableUrl,
//                         thumbnail: content.poster ?? content.banner ?? '',
//                         description: content.description ?? '',
//                       ),
//                       playlist: [],
//                     )));
//         }
//       } else {
//         await Navigator.push(
//           context,
//           MaterialPageRoute(
//             builder: (context) => VideoScreen(
//               videoUrl: playableUrl, bannerImageUrl: content.poster ?? content.banner ?? '',
//               videoId: content.id, name: content.name, updatedAt: content.updatedAt ?? '',
//               source: 'isVod', channelList: [], liveStatus: false,
//             ),
//           ),
//         );
//       }
//     } catch (e) {
//       if (mounted) {
//         ScaffoldMessenger.of(context).showSnackBar(
//           SnackBar(content: Text('Error: ${e.toString()}')),
//         );
//       }
//     } finally {
//       if (mounted) {
//         setState(() { _isVideoLoading = false; });
//       }
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       backgroundColor: ProfessionalColors.primaryDark,
//       body: Stack(
//         children: [
//           Container(
//             decoration: const BoxDecoration(
//               gradient: LinearGradient(
//                 colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)],
//                 begin: Alignment.topCenter, end: Alignment.bottomCenter,
//               ),
//             ),
//           ),
//           CustomScrollView(
//             slivers: [
//               SliverPadding(padding: EdgeInsets.only(top: 100.0)),
//               _isLoading
//                   ? const SliverFillRemaining(child: Center(child: CircularProgressIndicator()))
//                   : _error != null
//                       ? SliverFillRemaining(child: Center(child: Text('Error: $_error')))
//                       : _buildContentGrid(),
//             ]
//           ),
//             Positioned(
//             top: 0,
//             left: 0,
//             right: 0,
//             child: _buildBeautifulAppBar(),
//           ),
//           if (_isVideoLoading)
//             Container(
//               color: Colors.black.withOpacity(0.7),
//               child: const Center(
//                   child: CircularProgressIndicator(
//                 valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
//               )),
//             ),
//         ],
//       ),
//     );
//   }

//   Widget _buildBeautifulAppBar() {
//     return Container(
//       decoration: BoxDecoration(
//         gradient: LinearGradient(
//           begin: Alignment.topCenter,
//           end: Alignment.bottomCenter,
//           colors: [
//             ProfessionalColors.primaryDark.withOpacity(0.95),
//             ProfessionalColors.surfaceDark.withOpacity(0.9),
//             ProfessionalColors.surfaceDark.withOpacity(0.8),
//             Colors.transparent,
//           ],
//         ),
//         border: Border(
//           bottom: BorderSide(
//             color: ProfessionalColors.accentBlue.withOpacity(0.2),
//             width: 1,
//           ),
//         ),
//         boxShadow: [
//           BoxShadow(
//             color: Colors.black.withOpacity(0.3),
//             blurRadius: 10,
//             offset: const Offset(0, 2),
//           ),
//         ],
//       ),
//       child: ClipRRect(
//         child: BackdropFilter(
//           filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
//           child: Container(
//               padding: EdgeInsets.only(
//                 top: MediaQuery.of(context).padding.top + 10,
//                 left: 20,
//                 right: 30,
//                 bottom: 10,
//               ),
//               child: Row(
//                 mainAxisAlignment: MainAxisAlignment.spaceEvenly,
//                 children: [
//                   Container(
//                     decoration: BoxDecoration(
//                       shape: BoxShape.circle,
//                       gradient: LinearGradient(
//                         colors: [
//                           ProfessionalColors.accentBlue.withOpacity(0.3),
//                           ProfessionalColors.accentPurple.withOpacity(0.3),
//                         ],
//                       ),
//                     ),
//                     child: IconButton(
//                       icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24),
//                       onPressed: () => Navigator.pop(context),
//                     ),
//                   ),
//                   const SizedBox(width: 16),
//                   GradientText(
//                     widget.genre,
//                     style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22),
//                     gradient: const LinearGradient(colors: [
//                       ProfessionalColors.accentPink,
//                       ProfessionalColors.accentPurple,
//                       ProfessionalColors.accentBlue,
//                     ]),
//                   ),
//                   const SizedBox(width: 40),
//                   Expanded(
//                     child: Text(
//                       _focusedMovieName,
//                       textAlign: TextAlign.left,
//                       style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20),
//                       overflow: TextOverflow.ellipsis,
//                     ),
//                   ),
//                       Padding(
//                         padding: const EdgeInsets.only(right: 15.0),
//                         child: CircleAvatar(
//                           backgroundImage: NetworkImage(widget.logoUrl),
//                           radius: 20,
//                           backgroundColor: Colors.white24,
//                         ),
//                       ),
//                 ],
//               ),
//             ),
//         ),
//       ),
//     );
//   }


//   Widget _buildContentGrid() {
//     return SliverPadding(
//       padding: const EdgeInsets.all(30.0),
//       sliver: SliverGrid(
//         gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
//           crossAxisCount: 6,
//           childAspectRatio: 1.5,
//           mainAxisSpacing: 5,
//           crossAxisSpacing: 5,
//         ),
//         delegate: SliverChildBuilderDelegate(
//           (context, index) {
//             final movie = _movies[index];
//             return MovieCard(
//               key: _cardKeys[index],
//               movie: movie,
//               logoUrl: widget.logoUrl,
//               focusNode: _focusNodes[index],
//               focusColors: _focusColors,
//               uniqueIndex: index,
//               onTap: () => _playContent(movie),
//             );
//           },
//           childCount: _movies.length,
//         ),
//       ),
//     );
//   }
// }

// // ==========================================================
// // GRADIENT TEXT WIDGET - NO CHANGES
// // ==========================================================
// class GradientText extends StatelessWidget {
//   const GradientText(
//     this.text, {
//     super.key,
//     required this.gradient,
//     this.style,
//   });

//   final String text;
//   final TextStyle? style;
//   final Gradient gradient;

//   @override
//   Widget build(BuildContext context) {
//     return ShaderMask(
//       blendMode: BlendMode.srcIn,
//       shaderCallback: (bounds) => gradient.createShader(
//         Rect.fromLTWH(0, 0, bounds.width, bounds.height),
//       ),
//       child: Text(text, style: style),
//     );
//   }
// }

// // ==========================================================
// // HELPER FUNCTIONS (displayImage etc.) - NO CHANGES
// // ==========================================================
// Uint8List _getImageFromBase64String(String base64String) {
//   return base64Decode(base64String.split(',').last);
// }

// Widget displayImage(
//   String imageUrl, {
//   double? width,
//   double? height,
//   BoxFit fit = BoxFit.fill,
// }) {
//   if (imageUrl.isEmpty || imageUrl == 'localImage') {
//     return _buildErrorWidget(width, height);
//   }
//   if (imageUrl.contains('localhost')) {
//     return _buildErrorWidget(width, height);
//   }
//   if (imageUrl.startsWith('data:image')) {
//     try {
//       Uint8List imageBytes = _getImageFromBase64String(imageUrl);
//       return Image.memory(
//         imageBytes,
//         fit: fit,
//         width: width,
//         height: height,
//         errorBuilder: (context, error, stackTrace) {
//           return _buildErrorWidget(width, height);
//         },
//       );
//     } catch (e) {
//       return _buildErrorWidget(width, height);
//     }
//   } else if (imageUrl.startsWith('http') || imageUrl.startsWith('https')) {
//     if (imageUrl.toLowerCase().endsWith('.svg')) {
//       return SvgPicture.network(
//         imageUrl,
//         width: width,
//         height: height,
//         fit: fit,
//         placeholderBuilder: (context) {
//           return _buildLoadingWidget(width, height);
//         },
//       );
//     } else {
//       return Image.network(
//         imageUrl,
//         width: width,
//         height: height,
//         fit: fit,
//         headers: const {
//           'User-Agent': 'Flutter App',
//         },
//         loadingBuilder: (BuildContext context, Widget child,
//             ImageChunkEvent? loadingProgress) {
//           if (loadingProgress == null) {
//             return child;
//           }
//           return _buildLoadingWidget(width, height);
//         },
//         errorBuilder:
//             (BuildContext context, Object error, StackTrace? stackTrace) {
//           return _buildErrorWidget(width, height);
//         },
//       );
//     }
//   } else {
//     return _buildErrorWidget(width, height);
//   }
// }

// Widget _buildErrorWidget(double? width, double? height) {
//   return Container(
//     decoration: const BoxDecoration(
//       gradient: LinearGradient(
//         colors: [
//           ProfessionalColors.accentGreen,
//           ProfessionalColors.accentBlue,
//         ],
//       ),
//     ),
//     child: const Icon(
//       Icons.broken_image,
//       color: Colors.white,
//       size: 24,
//     ),
//   );
// }

// Widget _buildLoadingWidget(double? width, double? height) {
//   return SizedBox(
//     width: width,
//     height: height,
//     child: const Center(
//       child: CircularProgressIndicator(
//         strokeWidth: 2,
//         valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
//       ),
//     ),
//   );
// }




import 'dart:convert';
import 'dart:typed_data';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:http/http.dart' as http;
import 'package:mobi_tv_entertainment/main.dart';
import 'package:mobi_tv_entertainment/provider/internal_focus_provider.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:mobi_tv_entertainment/home_screen_pages/webseries_screen/webseries_details_page.dart';
import 'package:mobi_tv_entertainment/provider/device_info_provider.dart';
import 'package:mobi_tv_entertainment/video_widget/custom_youtube_player.dart';
import 'package:mobi_tv_entertainment/video_widget/video_screen.dart';
import 'package:mobi_tv_entertainment/video_widget/youtube_webview_player.dart';

// ==========================================================
// ENUMS AND DATA MODELS
// ==========================================================

enum LoadingState {
  initial,
  loading,
  rebuilding,
  loaded,
  error
}

class ParsedData {
  final List<String> genres;
  final Map<String, List<Movie>> moviesByGenre;

  ParsedData({required this.genres, required this.moviesByGenre});
}

// This function will run in the background isolate
ParsedData _parseJsonAndPrepareData(String jsonData) {
  final data = json.decode(jsonData) as Map<String, dynamic>;

  final allGenres = List<String>.from(data['genres']);
  final allMoviesByGenre = (data['moviesByGenre'] as Map<String, dynamic>).map(
      (key, value) => MapEntry(
          key, (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList()));
          
  final activeGenres = allGenres.where((g) => allMoviesByGenre[g]?.isNotEmpty ?? false).toList();

  return ParsedData(genres: activeGenres, moviesByGenre: allMoviesByGenre);
}

// ==========================================================
// PROFESSIONAL COLORS & DATA MODELS
// ==========================================================

class ProfessionalColors {
  static const primaryDark = Color(0xFF0A0E1A);
  static const surfaceDark = Color(0xFF1A1D29);
  static const cardDark = Color(0xFF2A2D3A);
  static const accentBlue = Color(0xFF3B82F6);
  static const accentPurple = Color(0xFF8B5CF6);
  static const accentGreen = Color(0xFF10B981);
  static const accentRed = Color(0xFFEF4444);
  static const accentOrange = Color(0xFFF59E0B);
  static const accentPink = Color(0xFFEC4899);
  static const textPrimary = Color(0xFFFFFFFF);
  static const textSecondary = Color(0xFFB3B3B3);
  static const focusGlow = Color(0xFF60A5FA);
}

class GenreResponse {
  final bool status;
  final List<String> genres;
  GenreResponse({required this.status, required this.genres});
  factory GenreResponse.fromJson(Map<String, dynamic> json) {
    return GenreResponse(
      status: json['status'],
      genres: List<String>.from(json['genres']),
    );
  }
}

class MovieResponse {
  final bool status;
  final int total;
  final List<Movie> data;
  MovieResponse({required this.status, required this.total, required this.data});
  factory MovieResponse.fromJson(Map<String, dynamic> json) {
    return MovieResponse(
      status: json['status'] ?? false,
      total: json['total'] ?? 0,
      data: (json['data'] as List).map((i) => Movie.fromJson(i)).toList(),
    );
  }
}

class Movie {
  final int id;
  final String name;
  final String? banner;
  final String? poster;
  final String? description;
  final int? contentType;
  final String? sourceType;
  final String? youtubeTrailer;
  final String? updatedAt;
  final String? movieUrl;
  final int? status;

  Movie({
    required this.id,
    required this.name,
    this.banner,
    this.poster,
    this.description,
    this.contentType,
    this.sourceType,
    this.youtubeTrailer,
    this.updatedAt,
    this.movieUrl,
    this.status,
  });

  factory Movie.fromJson(Map<String, dynamic> json) {
    return Movie(
      id: json['id'] ?? 0,
      name: json['name'] ?? 'No Name',
      banner: json['banner'],
      poster: json['poster'],
      description: json['description'],
      contentType: json['content_type'],
      sourceType: json['source_type'],
      youtubeTrailer: json['youtube_trailer'],
      updatedAt: json['updated_at'],
      movieUrl: json['movie_url'],
      status: json['status'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id, 'name': name, 'banner': banner, 'poster': poster,
      'description': description, 'content_type': contentType, 'source_type': sourceType,
      'youtube_trailer': youtubeTrailer, 'updated_at': updatedAt, 'movie_url': movieUrl,
      'status': status,
    };
  }

  factory Movie.fromMap(Map<String, dynamic> map) => Movie.fromJson(map);

  String getPlayableUrl() {
    if (sourceType == 'YoutubeLive') return movieUrl ?? '';
    if (youtubeTrailer != null && youtubeTrailer!.isNotEmpty) return youtubeTrailer!;
    return movieUrl ?? '';
  }
}

// ==========================================================
// PERFORMANCE MONITORING
// ==========================================================

class PerformanceMonitor {
  static final Map<String, Stopwatch> _stopwatches = {};
  
  static void startTimer(String operation) {
    _stopwatches[operation] = Stopwatch()..start();
  }
  
  static void endTimer(String operation) {
    final stopwatch = _stopwatches[operation];
    if (stopwatch != null) {
      stopwatch.stop();
      print('⏱️ $operation took: ${stopwatch.elapsedMilliseconds}ms');
      _stopwatches.remove(operation);
    }
  }
  
  static void logMemoryUsage(String operation) {
    if (kDebugMode) {
      print('🧠 Memory check at $operation');
    }
  }
}

// ==========================================================
// SMART CACHE MANAGER
// ==========================================================

class SmartCacheManager {
  static const String _cachePrefix = 'genre_movies_cache_';
  static const String _timestampSuffix = '_timestamp';
  static const Duration _cacheValidity = Duration(hours: 2);
  
  static String _getCacheKey(String tvChannelId) => '$_cachePrefix$tvChannelId';
  static String _getTimestampKey(String tvChannelId) => '$_cachePrefix$tvChannelId$_timestampSuffix';
  
  static Future<bool> isCacheValid(String tvChannelId) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final timestampStr = prefs.getString(_getTimestampKey(tvChannelId));
      
      if (timestampStr == null) return false;
      
      final cacheTime = DateTime.parse(timestampStr);
      final now = DateTime.now();
      final difference = now.difference(cacheTime);
      
      final isValid = difference < _cacheValidity;
      print('Cache validity check: ${isValid ? '✅ Valid' : '❌ Expired'} (Age: ${difference.inMinutes}min)');
      
      return isValid;
    } catch (e) {
      print('Cache validity check failed: $e');
      return false;
    }
  }
  
  static Future<String?> getCachedData(String tvChannelId) async {
    try {
      final isValid = await isCacheValid(tvChannelId);
      if (!isValid) return null;
      
      final prefs = await SharedPreferences.getInstance();
      final cachedData = prefs.getString(_getCacheKey(tvChannelId));
      
      if (cachedData != null && cachedData.isNotEmpty) {
        print('📦 Using cached data (${(cachedData.length / 1024).toStringAsFixed(1)}KB)');
        return cachedData;
      }
      
      return null;
    } catch (e) {
      print('Failed to get cached data: $e');
      return null;
    }
  }
  
  static Future<void> saveToCache(String tvChannelId, String data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final now = DateTime.now().toIso8601String();
      
      await Future.wait([
        prefs.setString(_getCacheKey(tvChannelId), data),
        prefs.setString(_getTimestampKey(tvChannelId), now),
      ]);
      
      print('💾 Data cached (${(data.length / 1024).toStringAsFixed(1)}KB) at $now');
    } catch (e) {
      print('Failed to save to cache: $e');
    }
  }
  
  static Future<void> clearCache(String tvChannelId) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await Future.wait([
        prefs.remove(_getCacheKey(tvChannelId)),
        prefs.remove(_getTimestampKey(tvChannelId)),
      ]);
      print('🗑️ Cache cleared for channel: $tvChannelId');
    } catch (e) {
      print('Failed to clear cache: $e');
    }
  }
  
  static Future<Map<String, dynamic>> getCacheInfo(String tvChannelId) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = _getCacheKey(tvChannelId);
      final timestampKey = _getTimestampKey(tvChannelId);
      
      final data = prefs.getString(cacheKey);
      final timestamp = prefs.getString(timestampKey);
      
      if (data == null || timestamp == null) {
        return {'exists': false};
      }
      
      final cacheTime = DateTime.parse(timestamp);
      final age = DateTime.now().difference(cacheTime);
      
      return {
        'exists': true,
        'size_kb': (data.length / 1024).toStringAsFixed(1),
        'timestamp': timestamp,
        'age_minutes': age.inMinutes,
        'is_valid': age < _cacheValidity,
      };
    } catch (e) {
      return {'exists': false, 'error': e.toString()};
    }
  }
}

// ==========================================================
// OPTIMIZED API FUNCTIONS
// ==========================================================

Future<String> _fetchAndCacheDataIsolateOptimized(Map<String, String> params) async {
  final String tvChannelId = params['tvChannelId']!;
  final String authKey = params['authKey']!;
  
  final client = http.Client();
  
  try {
    // Step 1: Fetch genres with timeout
    final genresResponse = await client.get(
      Uri.parse('https://dashboard.cpplayers.com/api/v2/getGenreByContentNetwork/$tvChannelId'),
      headers: {'auth-key': authKey, 'Accept': 'application/json', 'domain': 'coretechinfo.com'},
    ).timeout(
      const Duration(seconds: 15),
      onTimeout: () => throw Exception('Genres request timed out')
    );
    
    if (genresResponse.statusCode != 200) {
      throw Exception('Failed to load genres: ${genresResponse.statusCode}');
    }
    
    final genreData = GenreResponse.fromJson(json.decode(genresResponse.body));
    if (!genreData.status) return '';

    final genres = genreData.genres;
    print('📝 Found ${genres.length} genres, starting parallel fetch...');

    // Step 2: Create parallel futures with individual timeouts
    final List<Future<MapEntry<String, List<Movie>>>> genreFutures = genres.map((genre) async {
      try {
        final moviesResponse = await client.post(
          Uri.parse('https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew?page=1&records=10'),
          headers: {
            'auth-key': authKey,
            'domain': 'coretechinfo.com',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          },
          body: json.encode({"genre": genre, "network_id": tvChannelId}),
        ).timeout(
          const Duration(seconds: 10),
          onTimeout: () => throw Exception('$genre request timed out')
        );

        if (moviesResponse.statusCode == 200) {
          final movieData = MovieResponse.fromJson(json.decode(moviesResponse.body));
          if (movieData.status && movieData.data.isNotEmpty) {
            final activeMovies = movieData.data.where((movie) => movie.status == 1).toList();
            if (activeMovies.isNotEmpty) {
              return MapEntry(genre, activeMovies);
            }
          }
        }
        return MapEntry(genre, <Movie>[]);
      } catch (e) {
        print('Error fetching $genre: $e');
        return MapEntry(genre, <Movie>[]);
      }
    }).toList();

    // Step 3: Wait for all requests with overall timeout
    print('⚡ Executing ${genreFutures.length} parallel API calls...');
    final results = await Future.wait(genreFutures).timeout(
      const Duration(seconds: 30),
      onTimeout: () {
        print('⚠️ Overall request timeout, returning partial results');
        return genreFutures.map((future) => MapEntry('timeout', <Movie>[])).toList();
      }
    );
    
    // Step 4: Build the final map
    final Map<String, List<Movie>> moviesByGenre = {};
    int successCount = 0;
    for (final result in results) {
      if (result.key != 'timeout' && result.value.isNotEmpty) {
        moviesByGenre[result.key] = result.value;
        successCount++;
      }
    }
    
    print('✅ Parallel fetch complete: $successCount/${genres.length} genres loaded');
    
    final Map<String, dynamic> serializableData = {
      'genres': genres,
      'moviesByGenre': moviesByGenre.map((key, value) => 
        MapEntry(key, value.map((m) => m.toMap()).toList())),
    };
    
    return json.encode(serializableData);
    
  } catch (e) {
    print("Isolate Error: $e");
    return '';
  } finally {
    client.close();
  }
}

// ==========================================================
// SAFE LIST EXTENSION
// ==========================================================

extension SafeList<T> on List<T> {
  T? safeElementAt(int index) {
    if (index < 0 || index >= length) return null;
    return this[index];
  }
  
  bool isValidIndex(int index) {
    return index >= 0 && index < length;
  }
}

// ==========================================================
// GENRE MOVIES SCREEN (MAIN SCREEN)
// ==========================================================

class GenreMoviesScreen extends StatefulWidget {
  final String tvChannelId;
  final String logoUrl;
  final String title;
  const GenreMoviesScreen({super.key, required this.tvChannelId, required this.logoUrl, required this.title});
  @override
  State<GenreMoviesScreen> createState() => _GenreMoviesScreenState();
}

class _GenreMoviesScreenState extends State<GenreMoviesScreen> {
  LoadingState _loadingState = LoadingState.initial;
  String? _error;
  List<String> _genres = [];
  final Map<String, List<Movie>> _moviesByGenre = {};
  final List<List<FocusNode>> _focusNodes = [];
  final ScrollController _verticalScrollController = ScrollController();
  final Map<int, ScrollController> _horizontalScrollControllers = {};
  final List<GlobalKey> _rowKeys = [];
  final List<List<GlobalKey>> _cardKeys = [];
  final List<Color> _focusColors = [ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen, ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed];
  final List<Gradient> _genreBackgrounds = const [LinearGradient(colors: [Color(0xFF1A1D29), Color(0xFF0F121E)], begin: Alignment.topCenter, end: Alignment.bottomCenter), LinearGradient(colors: [Color(0xFF1C1A29), Color(0xFF110F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter), LinearGradient(colors: [Color(0xFF1A2129), Color(0xFF0F161E)], begin: Alignment.topCenter, end: Alignment.bottomCenter), LinearGradient(colors: [Color(0xFF211A29), Color(0xFF160F1E)], begin: Alignment.topCenter, end: Alignment.bottomCenter)];
  bool _isVideoLoading = false;
  String get _cacheKey => 'genre_movies_cache_${widget.tvChannelId}';

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
         Provider.of<InternalFocusProvider>(context, listen: false).updateName('');
      }
    });
    _loadInitialData();
  }

  @override
  void dispose() {
    _cleanupResources();
    super.dispose();
  }

  void _cleanupResources() {
    for (var row in _focusNodes) {
      for (var node in row) {
        node.dispose();
      }
    }
    _focusNodes.clear();

    _verticalScrollController.dispose();
    for (var controller in _horizontalScrollControllers.values) {
      controller.dispose();
    }
    _horizontalScrollControllers.clear();

    _cardKeys.clear();
    _rowKeys.clear();
    _moviesByGenre.clear();
    _genres.clear();
  }

  void _applyDataToState(ParsedData parsedData) {
    if (!mounted) return;

    setState(() {
      _loadingState = LoadingState.rebuilding;
    });

    // Clean up existing resources before creating new ones
    for (var row in _focusNodes) {
      for (var node in row) {
        node.dispose();
      }
    }
    _focusNodes.clear();
    
    for (var controller in _horizontalScrollControllers.values) {
      controller.dispose();
    }
    _horizontalScrollControllers.clear();

    _cardKeys.clear();
    _rowKeys.clear();

    // Apply new data
    _genres = parsedData.genres;
    _moviesByGenre.clear();
    _moviesByGenre.addAll(parsedData.moviesByGenre);

    // Create new keys and nodes
    _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));
    for (int i = 0; i < _genres.length; i++) {
      final movies = _moviesByGenre[_genres[i]] ?? [];
      int moviesToShow = movies.length > 10 ? 10 : movies.length;
      int nodeCount = moviesToShow + 1;
      var rowNodes = List.generate(nodeCount, (_) => FocusNode());
      var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
      _cardKeys.add(rowCardKeys);
      _horizontalScrollControllers[i] = ScrollController();
      for (int j = 0; j < nodeCount; j++) {
        rowNodes[j].addListener(() {
          if (rowNodes[j].hasFocus) _onItemFocusChange(i, j);
        });
      }
      _focusNodes.add(rowNodes);
    }

    setState(() {
      _loadingState = LoadingState.loaded;
    });

    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted && _focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
        _focusNodes.first.first.requestFocus();
      }
    });
  }

  Future<void> _loadInitialData() async {
    final cachedData = await SmartCacheManager.getCachedData(widget.tvChannelId);
    
    if (cachedData != null) {
      print('🚀 Loading from valid cache...');
      PerformanceMonitor.startTimer('cacheLoad');
      
      _parseAndSetState(cachedData);
      
      PerformanceMonitor.endTimer('cacheLoad');
      
      final cacheInfo = await SmartCacheManager.getCacheInfo(widget.tvChannelId);
      if (cacheInfo['age_minutes'] > 60) {
        print('🔄 Starting background refresh (cache age: ${cacheInfo['age_minutes']}min)');
        _refreshDataInBackground();
      }
      
      return;
    }
    
    print('📡 No valid cache found, fetching fresh data...');
    await _fetchDataWithLoading();
  }

  Future<void> _refreshDataInBackground() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final authKey = prefs.getString('result_auth_key') ?? '56456456456';
      
      final String freshDataJson = await _fetchAndCacheDataIsolateOptimized({
        'tvChannelId': widget.tvChannelId, 
        'authKey': authKey
      });
      
      if (freshDataJson.isNotEmpty) {
        await SmartCacheManager.saveToCache(widget.tvChannelId, freshDataJson);
        print('✅ Background refresh completed and cached');
      }
    } catch (e) {
      print('Background refresh failed: $e');
    }
  }

  Future<void> _fetchDataWithLoading() async {
    PerformanceMonitor.startTimer('fetchData');
    
    if (mounted) setState(() { 
      _loadingState = LoadingState.loading; 
      _error = null; 
    });
    
    try {
      final prefs = await SharedPreferences.getInstance();
      final authKey = prefs.getString('result_auth_key') ?? '56456456456';
      
      PerformanceMonitor.startTimer('isolateWork');
      final String freshDataJson = await _fetchAndCacheDataIsolateOptimized({
        'tvChannelId': widget.tvChannelId, 
        'authKey': authKey
      });
      PerformanceMonitor.endTimer('isolateWork');

      if (freshDataJson.isNotEmpty) {
        await SmartCacheManager.saveToCache(widget.tvChannelId, freshDataJson);
        
        PerformanceMonitor.startTimer('parseData');
        final parsedData = await compute(_parseJsonAndPrepareData, freshDataJson);
        PerformanceMonitor.endTimer('parseData');

        PerformanceMonitor.startTimer('applyState');
        _applyDataToState(parsedData);
        PerformanceMonitor.endTimer('applyState');

      } else {
        throw Exception('Failed to load data');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
          _loadingState = LoadingState.error;
        });
      }
    }
    
    PerformanceMonitor.endTimer('fetchData');
    PerformanceMonitor.logMemoryUsage('fetchDataComplete');
  }

  void _parseAndSetState(String jsonData) {
    if (!mounted) return;

    setState(() {
      _loadingState = LoadingState.rebuilding;
    });

    final data = json.decode(jsonData) as Map<String, dynamic>;
    
    for (var row in _focusNodes) {
      for (var node in row) {
        node.dispose();
      }
    }
    _focusNodes.clear();
    
    for (var controller in _horizontalScrollControllers.values) {
      controller.dispose();
    }
    _horizontalScrollControllers.clear();

    _cardKeys.clear();
    _rowKeys.clear();

    final allGenres = List<String>.from(data['genres']);
    final allMoviesByGenre = (data['moviesByGenre'] as Map<String, dynamic>).map((key, value) => MapEntry(key, (value as List).map((movieMap) => Movie.fromMap(movieMap)).toList()));
    final activeGenres = allGenres.where((g) => allMoviesByGenre[g]?.isNotEmpty ?? false).toList();

    _genres = activeGenres;
    _moviesByGenre.clear();
    _moviesByGenre.addAll(allMoviesByGenre);

    _rowKeys.addAll(List.generate(_genres.length, (_) => GlobalKey()));
    for (int i = 0; i < _genres.length; i++) {
      final movies = _moviesByGenre[_genres[i]] ?? [];
      int moviesToShow = movies.length > 10 ? 10 : movies.length;
      int nodeCount = moviesToShow + 1;
      var rowNodes = List.generate(nodeCount, (_) => FocusNode());
      var rowCardKeys = List.generate(nodeCount, (_) => GlobalKey());
      _cardKeys.add(rowCardKeys);
      _horizontalScrollControllers[i] = ScrollController();
      for (int j = 0; j < nodeCount; j++) {
        rowNodes[j].addListener(() {
          if (rowNodes[j].hasFocus) _onItemFocusChange(i, j);
        });
      }
      _focusNodes.add(rowNodes);
    }

    setState(() {
      _loadingState = LoadingState.loaded;
    });

    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted && _focusNodes.isNotEmpty && _focusNodes.first.isNotEmpty) {
        _focusNodes.first.first.requestFocus();
      }
    });
  }

  void _onItemFocusChange(int genreIndex, int movieIndex) {
    if (!mounted || _loadingState == LoadingState.loading || genreIndex < 0 || genreIndex >= _genres.length) return;
    final genre = _genres[genreIndex];
    final movies = _moviesByGenre[genre] ?? [];
    int moviesToShow = movies.length > 10 ? 10 : movies.length;
    int expectedNodeCount = moviesToShow + 1;
    if (movieIndex < 0 || movieIndex >= expectedNodeCount) return;

    String newName = movieIndex < moviesToShow ? movies[movieIndex].name : "View All";
    Provider.of<InternalFocusProvider>(context, listen: false).updateName(newName);

    _scrollToFocusedVertical(genreIndex);
    _scrollToFocusedHorizontal(genreIndex, movieIndex);
  }

  void _scrollToFocusedVertical(int genreIndex) {
    if (_loadingState == LoadingState.loading || genreIndex < 0 || genreIndex >= _rowKeys.length) return;
    final rowContext = _rowKeys[genreIndex].currentContext;
    if (rowContext == null) return;
    final renderBox = rowContext.findRenderObject() as RenderBox;
    final rowOffset = renderBox.localToGlobal(Offset.zero);
    final scrollOffset = _verticalScrollController.offset;
    const appBarHeight = 100.0;
    final rowTop = rowOffset.dy + scrollOffset - (screenhgt * 0.5 - appBarHeight * 0.5);
    _verticalScrollController.animateTo(rowTop.clamp(0.0, _verticalScrollController.position.maxScrollExtent), duration: const Duration(milliseconds: 350), curve: Curves.easeOut);
  }

  void _scrollToFocusedHorizontal(int genreIndex, int movieIndex) {
    if (_loadingState == LoadingState.loading || genreIndex < 0 || genreIndex >= _horizontalScrollControllers.length || genreIndex >= _cardKeys.length) return;
    if (movieIndex < 0 || movieIndex >= _cardKeys[genreIndex].length) return;
    final scrollController = _horizontalScrollControllers[genreIndex];
    if (scrollController == null || !scrollController.hasClients) return;
    final cardContext = _cardKeys[genreIndex][movieIndex].currentContext;
    if (cardContext == null) return;
    final renderBox = cardContext.findRenderObject() as RenderBox;
    final cardOffset = renderBox.localToGlobal(Offset.zero, ancestor: scrollController.position.context.storageContext.findRenderObject());
    double targetOffset = (scrollController.offset + cardOffset.dx - 40).clamp(0.0, scrollController.position.maxScrollExtent);
    scrollController.animateTo(targetOffset, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
  }

  // Future<void> _playContent(Movie content) async {
  //   if (_isVideoLoading || !mounted) return;
  //   setState(() => _isVideoLoading = true);
  //   try {
  //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Playing: ${content.name}')));
  //   } catch (e) {
  //     if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
  //   } finally {
  //     if (mounted) setState(() => _isVideoLoading = false);
  //   }
  // }




  // // Replace the old _playContent with this complete version
Future<void> _playContent(Movie content) async {
  if (_isVideoLoading || !mounted) return;
  setState(() { _isVideoLoading = true; });

  try {
    String playableUrl = content.getPlayableUrl();

    // Navigate to Web Series details page if content type is 2
    if (content.contentType == 2) {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => WebSeriesDetailsPage(
            id: content.id,
            banner: content.banner ?? '',
            poster: content.poster ?? '',
            logo: widget.logoUrl,
            name: content.name,
            updatedAt: content.updatedAt ?? '',
          ),
        ),
      );
      return; // Stop execution after navigation
    }

    if (playableUrl.isEmpty) {
      throw Exception('No video URL found');
    }

    if (!mounted) return;

    // Handle YouTube links
    if (content.sourceType == 'YoutubeLive' || (content.youtubeTrailer != null && content.youtubeTrailer!.isNotEmpty)) {
      final deviceInfo = context.read<DeviceInfoProvider>();
      if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
        // Use WebView for specific devices like Fire Stick
        await Navigator.push(context, MaterialPageRoute(builder: (context) => YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
      } else {
        // Use the custom YouTube player for other devices
        await Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => CustomYoutubePlayer(
              videoData: VideoData(
                id: playableUrl
                title: content.name,
                youtubeUrl: playableUrl,
                thumbnail: content.poster ?? content.banner ?? '',
                description: content.description ?? '',
              ),
              playlist: [],
            ),
          ),
        );
      }
    } else {
      // Handle other video URLs
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => VideoScreen(
            videoUrl: playableUrl,
            bannerImageUrl: content.poster ?? content.banner ?? '',
            videoId: content.id,
            name: content.name,
            updatedAt: content.updatedAt ?? '',
            source: 'isVod',
            channelList: [],
            liveStatus: false,
          ),
        ),
      );
    }
  } catch (e) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
    }
  } finally {
    if (mounted) {
      setState(() { _isVideoLoading = false; });
    }
  }
}

  void _navigateToGridPage(String genre) {
    Navigator.push(context, MaterialPageRoute(builder: (context) => GenreGridScreen(genre: genre, tvChannelId: widget.tvChannelId, logoUrl: widget.logoUrl)));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: ProfessionalColors.primaryDark,
      body: Stack(
        children: [
          Container(decoration: const BoxDecoration(gradient: LinearGradient(colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)], begin: Alignment.topCenter, end: Alignment.bottomCenter))),
          CustomScrollView(
            controller: _verticalScrollController,
            slivers: [
              const SliverPadding(padding: EdgeInsets.only(top: 100.0)),
              _loadingState == LoadingState.loading || _loadingState == LoadingState.initial 
                ? const SliverFillRemaining(child: Center(child: CircularProgressIndicator())) 
                : _error != null 
                  ? SliverFillRemaining(child: Center(child: Text('Error: $_error'))) 
                  : _buildGenresList(),
            ],
          ),
          Positioned(top: 0, left: 0, right: 0, child: _buildBeautifulAppBar()),
          if (_isVideoLoading) Container(color: Colors.black.withOpacity(0.7), child: const Center(child: CircularProgressIndicator(valueColor: AlwaysStoppedAnimation<Color>(Colors.white)))),
        ],
      ),
    );
  }

  Widget _buildBeautifulAppBar() {
    final focusedName = context.watch<InternalFocusProvider>().focusedItemName;
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [ProfessionalColors.primaryDark.withOpacity(0.95), ProfessionalColors.surfaceDark.withOpacity(0.9), ProfessionalColors.surfaceDark.withOpacity(0.8), Colors.transparent]),
        border: Border(bottom: BorderSide(color: ProfessionalColors.accentBlue.withOpacity(0.2), width: 1)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 10, offset: const Offset(0, 2))],
      ),
      child: ClipRRect(
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
          child: Container(
            padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top + 10, left: 20, right: 30, bottom: 10),
            child: Row(
              children: [
                Container(decoration: BoxDecoration(shape: BoxShape.circle, gradient: LinearGradient(colors: [ProfessionalColors.accentBlue.withOpacity(0.3), ProfessionalColors.accentPurple.withOpacity(0.3)])), child: IconButton(icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24), onPressed: () => Navigator.pop(context))),
                const SizedBox(width: 16),
                GradientText(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22), gradient: const LinearGradient(colors: [ProfessionalColors.accentPink, ProfessionalColors.accentPurple, ProfessionalColors.accentBlue])),
                const SizedBox(width: 40),
                Expanded(child: Text(focusedName, textAlign: TextAlign.left, style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20), overflow: TextOverflow.ellipsis)),
                Padding(padding: const EdgeInsets.only(right: 15.0), child: CircleAvatar(backgroundImage: NetworkImage(widget.logoUrl), radius: 20, backgroundColor: Colors.white24)),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildGenresList() {
    if (_loadingState == LoadingState.rebuilding || _genres.isEmpty) {
      return const SliverToBoxAdapter(child: SizedBox.shrink());
    }
    return SliverList(
      delegate: SliverChildBuilderDelegate((context, index) {
        final genre = _genres[index];
        final movies = _moviesByGenre[genre] ?? [];
        final int moviesToShow = movies.length > 10 ? 10 : movies.length;
        final int itemCount = moviesToShow + 1;
        return Container(
          key: _rowKeys[index],
          decoration: BoxDecoration(gradient: _genreBackgrounds[index % _genreBackgrounds.length]),
          padding: const EdgeInsets.symmetric(vertical: 5.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(padding: const EdgeInsets.only(left: 30.0, bottom: 5.0), child: GradientText(genre, style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, letterSpacing: 1.2), gradient: const LinearGradient(colors: [ProfessionalColors.accentGreen, ProfessionalColors.accentOrange, ProfessionalColors.accentPink], begin: Alignment.topLeft, end: Alignment.bottomRight))),
              SizedBox(
                height: bannerhgt + 25,
                child: ListView.builder(
                  controller: _horizontalScrollControllers[index], 
                  scrollDirection: Axis.horizontal, 
                  itemCount: itemCount, 
                  padding: const EdgeInsets.symmetric(horizontal: 30.0),
                  itemBuilder: (context, movieIndex) {
                    try {
                      if (!_genres.isValidIndex(index)) {
                        print('Invalid genre index: $index, genres length: ${_genres.length}');
                        return Container(width: bannerwdt, child: const Text('Invalid genre'));
                      }
                      
                      if (!_cardKeys.isValidIndex(index) || !_cardKeys[index].isValidIndex(movieIndex)) {
                        print('Invalid card key index: genre=$index, movie=$movieIndex');
                        return Container(width: bannerwdt, child: const Text('Invalid card key'));
                      }
                      
                      if (!_focusNodes.isValidIndex(index) || !_focusNodes[index].isValidIndex(movieIndex)) {
                        print('Invalid focus node index: genre=$index, movie=$movieIndex');
                        return Container(width: bannerwdt, child: const Text('Invalid focus node'));
                      }

                      if (movieIndex == moviesToShow) {
                        return ViewAllCard(
                          key: _cardKeys[index][movieIndex],
                          focusNode: _focusNodes[index][movieIndex],
                          focusColors: _focusColors,
                          uniqueIndex: index * 10 + movieIndex,
                          onTap: () => _navigateToGridPage(genre)
                        );
                      }
                      
                      final movie = movies.safeElementAt(movieIndex);
                      if (movie == null) {
                        print('Movie not found at index: $movieIndex, movies length: ${movies.length}');
                        return Container(width: bannerwdt, child: const Text('Movie not found'));
                      }
                      
                      return MovieCard(
                        key: _cardKeys[index][movieIndex],
                        movie: movie,
                        logoUrl: widget.logoUrl,
                        focusNode: _focusNodes[index][movieIndex],
                        focusColors: _focusColors,
                        uniqueIndex: index * 10 + movieIndex,
                        onTap: () => _playContent(movie)
                      );
                      
                    } catch (e, stackTrace) {
                      print('🚨 ListView Builder Error 🚨');
                      print('Genre Index: $index, Movie Index: $movieIndex');
                      print('Error: $e');
                      print('StackTrace: $stackTrace');
                      return Container(
                        width: bannerwdt, 
                        height: 100,
                        color: Colors.red.withOpacity(0.3),
                        child: const Center(child: Text('Error', style: TextStyle(color: Colors.white)))
                      );
                    }
                  },
                ),
              ),
            ],
          ),
        );
      }, childCount: _genres.length),
    );
  }
}

// ==========================================================
// GENRE GRID SCREEN
// ==========================================================

List<Movie> _parseGridData(String responseBody) {
  final movieData = MovieResponse.fromJson(json.decode(responseBody));
  if (movieData.status) {
    return movieData.data.where((movie) => movie.status == 1).toList();
  } else {
    return [];
  }
}

class GenreGridScreen extends StatefulWidget {
  final String genre;
  final String tvChannelId;
  final String logoUrl;
  const GenreGridScreen({super.key, required this.genre, required this.tvChannelId, required this.logoUrl});
  @override
  State<GenreGridScreen> createState() => _GenreGridScreenState();
}

class _GenreGridScreenState extends State<GenreGridScreen> {
  bool _isLoading = true;
  String? _error;
  List<Movie> _movies = [];
  List<FocusNode> _focusNodes = [];
  List<GlobalKey> _cardKeys = [];
  bool _isVideoLoading = false;
  final List<Color> _focusColors = [ProfessionalColors.accentBlue, ProfessionalColors.accentPurple, ProfessionalColors.accentGreen, ProfessionalColors.accentOrange, ProfessionalColors.accentPink, ProfessionalColors.accentRed];

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        Provider.of<InternalFocusProvider>(context, listen: false).updateName(widget.genre);
      }
    });
    _fetchGridData();
  }

  @override
  void dispose() {
    for (var node in _focusNodes) { 
      node.dispose(); 
    }
    super.dispose();
  }

  void _applyMoviesToState(List<Movie> movies) {
    if (!mounted) return;

    setState(() {
      _movies = movies;
      _focusNodes = List.generate(_movies.length, (index) => FocusNode());
      _cardKeys = List.generate(_movies.length, (index) => GlobalKey());

      for (int i = 0; i < _focusNodes.length; i++) {
        _focusNodes[i].addListener(() {
          if (_focusNodes[i].hasFocus) _onItemFocusChange(i);
        });
      }

      _isLoading = false;
    });

    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted && _focusNodes.isNotEmpty) _focusNodes.first.requestFocus();
    });
  }

  Future<void> _fetchGridData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final authKey = prefs.getString('result_auth_key') ?? '56456456456';

      final moviesResponse = await http.post(
        Uri.parse('https://dashboard.cpplayers.com/api/v2/getAllContentsOfNetworkNew'),
        headers: {'auth-key': authKey, 'domain': 'coretechinfo.com', 'Accept': 'application/json', 'Content-Type': 'application/json'},
        body: json.encode({"genre": widget.genre, "network_id": widget.tvChannelId}),
      );

      if (moviesResponse.statusCode == 200) {
        final List<Movie> parsedMovies = await compute(_parseGridData, moviesResponse.body);
        _applyMoviesToState(parsedMovies);
      } else {
        throw Exception('Failed to load content for ${widget.genre}');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
          _isLoading = false;
        });
      }
    }
  }

  void _onItemFocusChange(int index) {
    if (!mounted || _isLoading || index < 0 || index >= _movies.length) return;

    Provider.of<InternalFocusProvider>(context, listen: false).updateName(_movies[index].name);

    final cardContext = _cardKeys[index].currentContext;
    if (cardContext != null) {
      Scrollable.ensureVisible(cardContext,
          duration: const Duration(milliseconds: 350),
          curve: Curves.easeOut,
          alignment: 0.15);
    }
  }

  // Future<void> _playContent(Movie content) async {
  //   if (_isVideoLoading || !mounted) return;
  //   setState(() => _isVideoLoading = true);
  //   try {
  //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Playing: ${content.name}')));
  //   } catch (e) {
  //     if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
  //   } finally {
  //     if (mounted) setState(() => _isVideoLoading = false);
  //   }
  // }




  // // Replace the old _playContent with this complete version
Future<void> _playContent(Movie content) async {
  if (_isVideoLoading || !mounted) return;
  setState(() { _isVideoLoading = true; });

  try {
    String playableUrl = content.getPlayableUrl();

    // Navigate to Web Series details page if content type is 2
    if (content.contentType == 2) {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => WebSeriesDetailsPage(
            id: content.id,
            banner: content.banner ?? '',
            poster: content.poster ?? '',
            logo: widget.logoUrl,
            name: content.name,
            updatedAt: content.updatedAt ?? '',
          ),
        ),
      );
      return; // Stop execution after navigation
    }

    if (playableUrl.isEmpty) {
      throw Exception('No video URL found');
    }

    if (!mounted) return;

    // Handle YouTube links
    if (content.sourceType == 'YoutubeLive' || (content.youtubeTrailer != null && content.youtubeTrailer!.isNotEmpty)) {
      final deviceInfo = context.read<DeviceInfoProvider>();
      if (deviceInfo.deviceName == 'AFTSS : Amazon Fire Stick HD') {
        // Use WebView for specific devices like Fire Stick
        await Navigator.push(context, MaterialPageRoute(builder: (context) => YoutubeWebviewPlayer(videoUrl: playableUrl, name: content.name)));
      } else {
        // Use the custom YouTube player for other devices
        await Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => CustomYoutubePlayer(
              videoData: VideoData(
                id: playableUrl,
                title: content.name,
                youtubeUrl: playableUrl,
                thumbnail: content.poster ?? content.banner ?? '',
                description: content.description ?? '',
              ),
              playlist: [],
            ),
          ),
        );
      }
    } else {
      // Handle other video URLs
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => VideoScreen(
            videoUrl: playableUrl,
            bannerImageUrl: content.poster ?? content.banner ?? '',
            videoId: content.id,
            name: content.name,
            updatedAt: content.updatedAt ?? '',
            source: 'isVod',
            channelList: [],
            liveStatus: false,
          ),
        ),
      );
    }
  } catch (e) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
    }
  } finally {
    if (mounted) {
      setState(() { _isVideoLoading = false; });
    }
  }
}

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: ProfessionalColors.primaryDark,
      body: Stack(
        children: [
          Container(decoration: const BoxDecoration(gradient: LinearGradient(colors: [ProfessionalColors.primaryDark, Color(0xFF06080F)], begin: Alignment.topCenter, end: Alignment.bottomCenter))),
          CustomScrollView(
            slivers: [
              const SliverPadding(padding: EdgeInsets.only(top: 100.0)),
              _isLoading ? const SliverFillRemaining(child: Center(child: CircularProgressIndicator())) : _error != null ? SliverFillRemaining(child: Center(child: Text('Error: $_error'))) : _buildContentGrid(),
            ]
          ),
          Positioned(top: 0, left: 0, right: 0, child: _buildBeautifulAppBar()),
          if (_isVideoLoading) Container(color: Colors.black.withOpacity(0.7), child: const Center(child: CircularProgressIndicator(valueColor: AlwaysStoppedAnimation<Color>(Colors.white)))),
        ],
      ),
    );
  }

  Widget _buildBeautifulAppBar() {
    final focusedName = context.watch<InternalFocusProvider>().focusedItemName;
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [ProfessionalColors.primaryDark.withOpacity(0.95), ProfessionalColors.surfaceDark.withOpacity(0.9), ProfessionalColors.surfaceDark.withOpacity(0.8), Colors.transparent]),
        border: Border(bottom: BorderSide(color: ProfessionalColors.accentBlue.withOpacity(0.2), width: 1)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 10, offset: const Offset(0, 2))],
      ),
      child: ClipRRect(
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 0, sigmaY: 0),
          child: Container(
            padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top + 10, left: 20, right: 30, bottom: 10),
            child: Row(
              children: [
                Container(decoration: BoxDecoration(shape: BoxShape.circle, gradient: LinearGradient(colors: [ProfessionalColors.accentBlue.withOpacity(0.3), ProfessionalColors.accentPurple.withOpacity(0.3)])), child: IconButton(icon: const Icon(Icons.arrow_back_rounded, color: Colors.white, size: 24), onPressed: () => Navigator.pop(context))),
                const SizedBox(width: 16),
                GradientText(widget.genre, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 22), gradient: const LinearGradient(colors: [ProfessionalColors.accentPink, ProfessionalColors.accentPurple, ProfessionalColors.accentBlue])),
                const SizedBox(width: 40),
                Expanded(child: Text(focusedName, textAlign: TextAlign.left, style: const TextStyle(color: ProfessionalColors.textSecondary, fontWeight: FontWeight.bold, fontSize: 20), overflow: TextOverflow.ellipsis)),
                Padding(padding: const EdgeInsets.only(right: 15.0), child: CircleAvatar(backgroundImage: NetworkImage(widget.logoUrl), radius: 20, backgroundColor: Colors.white24)),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildContentGrid() {
    return SliverPadding(
      padding: const EdgeInsets.all(30.0),
      sliver: SliverGrid(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 6, childAspectRatio: 1.5, mainAxisSpacing: 5, crossAxisSpacing: 5),
        delegate: SliverChildBuilderDelegate((context, index) {
          final movie = _movies[index];
          return MovieCard(key: _cardKeys[index], movie: movie, logoUrl: widget.logoUrl, focusNode: _focusNodes[index], focusColors: _focusColors, uniqueIndex: index, onTap: () => _playContent(movie));
        }, childCount: _movies.length),
      ),
    );
  }
}

// ==========================================================
// REUSABLE WIDGETS
// ==========================================================

class MovieCard extends StatefulWidget {
  final Movie movie; 
  final String logoUrl; 
  final FocusNode focusNode; 
  final List<Color> focusColors; 
  final int uniqueIndex; 
  final VoidCallback onTap; 
  final bool isFirst; 
  final bool isLast;
  
  const MovieCard({super.key, required this.movie, required this.logoUrl, required this.focusNode, required this.focusColors, required this.uniqueIndex, required this.onTap, this.isFirst = false, this.isLast = false});
  
  @override
  State<MovieCard> createState() => _MovieCardState();
}

class _MovieCardState extends State<MovieCard> {
  bool _hasFocus = false;
  
  @override
  void initState() { 
    super.initState(); 
    widget.focusNode.addListener(_onFocusChange); 
  }
  
  @override
  void dispose() { 
    widget.focusNode.removeListener(_onFocusChange); 
    super.dispose(); 
  }

  void _onFocusChange() {
    if (mounted && widget.focusNode.hasFocus != _hasFocus) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _hasFocus = widget.focusNode.hasFocus;
          });
        }
      });
    }
  }
  
  KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) { 
        widget.onTap(); 
        return KeyEventResult.handled; 
      }
      if (widget.isFirst && event.logicalKey == LogicalKeyboardKey.arrowLeft) return KeyEventResult.handled;
      if (widget.isLast && event.logicalKey == LogicalKeyboardKey.arrowRight) return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  @override
  Widget build(BuildContext context) {
    final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];
    return Focus(
      focusNode: widget.focusNode, 
      onKey: _handleKeyEvent,
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          width: bannerwdt, 
          margin: const EdgeInsets.only(right: 12.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(8.0), 
                    border: _hasFocus ? Border.all(color: focusColor, width: 3) : Border.all(color: Colors.transparent, width: 3), 
                    boxShadow: _hasFocus ? [BoxShadow(color: focusColor.withOpacity(0.5), blurRadius: 12, spreadRadius: 1)] : []
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(6.0),
                    child: Stack(
                      fit: StackFit.expand,
                      children: [
                        displayImage(widget.movie.banner ?? '', fit: BoxFit.cover),
                        if (widget.movie.contentType == 2) Positioned(bottom: 8, left: 8, child: Container(padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4), decoration: BoxDecoration(color: ProfessionalColors.accentPurple.withOpacity(0.9), borderRadius: BorderRadius.circular(4.0)), child: const Text('Web Series', style: TextStyle(color: ProfessionalColors.textPrimary, fontSize: 10, fontWeight: FontWeight.bold)))),
                        if (_hasFocus) Positioned(left: 5, top: 5, child: Container(color: Colors.black.withOpacity(0.4), child: Icon(Icons.play_circle_filled_outlined, color: focusColor, size: 40))),
                        Positioned(top: 5, right: 5, child: CircleAvatar(radius: 12, backgroundImage: NetworkImage(widget.logoUrl), backgroundColor: Colors.black54)),
                      ],
                    ),
                  ),
                ),
              ),
              Padding(padding: const EdgeInsets.only(top: 2.0, left: 2.0, right: 2.0), child: Text(widget.movie.name, style: TextStyle(color: _hasFocus ? focusColor : ProfessionalColors.textSecondary, fontSize: 14), maxLines: 1, overflow: TextOverflow.ellipsis)),
            ],
          ),
        ),
      ),
    );
  }
}

class ViewAllCard extends StatefulWidget {
  final FocusNode focusNode; 
  final List<Color> focusColors; 
  final int uniqueIndex; 
  final VoidCallback onTap;
  
  const ViewAllCard({super.key, required this.focusNode, required this.focusColors, required this.uniqueIndex, required this.onTap});
  
  @override
  State<ViewAllCard> createState() => _ViewAllCardState();
}

class _ViewAllCardState extends State<ViewAllCard> {
  bool _hasFocus = false;
  
  @override
  void initState() { 
    super.initState(); 
    widget.focusNode.addListener(_onFocusChange); 
  }
  
  @override
  void dispose() { 
    widget.focusNode.removeListener(_onFocusChange); 
    super.dispose(); 
  }

  void _onFocusChange() {
    if (mounted && widget.focusNode.hasFocus != _hasFocus) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _hasFocus = widget.focusNode.hasFocus;
          });
        }
      });
    }
  }

  KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      if (event.logicalKey == LogicalKeyboardKey.select || event.logicalKey == LogicalKeyboardKey.enter) { 
        widget.onTap(); 
        return KeyEventResult.handled; 
      }
      if (event.logicalKey == LogicalKeyboardKey.arrowRight) return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  @override
  Widget build(BuildContext context) {
    final focusColor = widget.focusColors[widget.uniqueIndex % widget.focusColors.length];
    return Focus(
      focusNode: widget.focusNode, 
      onKey: _handleKeyEvent,
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          width: bannerwdt, 
          margin: const EdgeInsets.only(right: 12.0),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(10.0), 
            border: _hasFocus ? Border.all(color: focusColor, width: 3) : Border.all(color: Colors.transparent, width: 3), 
            boxShadow: _hasFocus ? [BoxShadow(color: ProfessionalColors.focusGlow.withOpacity(0.7), blurRadius: 12, spreadRadius: 1)] : []
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(8.0),
            child: Container(
              color: ProfessionalColors.cardDark,
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.arrow_forward, color: _hasFocus ? focusColor : Colors.white70, size: 32),
                    const SizedBox(height: 8),
                    Text("View All", style: TextStyle(color: _hasFocus ? focusColor : Colors.white70, fontWeight: FontWeight.bold)),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class GradientText extends StatelessWidget {
  const GradientText(this.text, {super.key, required this.gradient, this.style});
  final String text; 
  final TextStyle? style; 
  final Gradient gradient;
  
  @override
  Widget build(BuildContext context) {
    return ShaderMask(
      blendMode: BlendMode.srcIn,
      shaderCallback: (bounds) => gradient.createShader(Rect.fromLTWH(0, 0, bounds.width, bounds.height)),
      child: Text(text, style: style),
    );
  }
}

// ==========================================================
// HELPER FUNCTIONS
// ==========================================================

Uint8List _getImageFromBase64String(String base64String) => base64Decode(base64String.split(',').last);

Widget displayImage(String imageUrl, {double? width, double? height, BoxFit fit = BoxFit.cover}) {
  if (imageUrl.isEmpty || imageUrl == 'localImage' || imageUrl.contains('localhost')) {
    return _buildErrorWidget(width, height);
  }
  if (imageUrl.startsWith('data:image')) {
    try {
      return Image.memory(_getImageFromBase64String(imageUrl), fit: fit, width: width, height: height, errorBuilder: (c, e, s) => _buildErrorWidget(width, height));
    } catch (e) {
      return _buildErrorWidget(width, height);
    }
  } else if (imageUrl.startsWith('http')) {
    if (imageUrl.toLowerCase().endsWith('.svg')) {
      return SvgPicture.network(imageUrl, width: width, height: height, fit: fit, placeholderBuilder: (c) => _buildLoadingWidget(width, height));
    } else {
      return Image.network(
        imageUrl, width: width, height: height, fit: fit,
        headers: const {'User-Agent': 'Flutter App'},
        loadingBuilder: (c, child, progress) => progress == null ? child : _buildLoadingWidget(width, height),
        errorBuilder: (c, e, s) => _buildErrorWidget(width, height),
      );
    }
  } else {
    return _buildErrorWidget(width, height);
  }
}

Widget _buildErrorWidget(double? width, double? height) {
  return Container(
    width: width, 
    height: height,
    decoration: const BoxDecoration(gradient: LinearGradient(colors: [ProfessionalColors.accentGreen, ProfessionalColors.accentBlue])),
    child: const Icon(Icons.broken_image, color: Colors.white, size: 24),
  );
}

Widget _buildLoadingWidget(double? width, double? height) {
  return SizedBox(
    width: width, 
    height: height,
    child: const Center(child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white))),
  );
}